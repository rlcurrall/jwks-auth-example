From 9b8f153efe1234e4e428d40135210fcd5ceca5bb Mon Sep 17 00:00:00 2001
From: Robb Currall <robb.currall@vantaca.com>
Date: Thu, 3 Apr 2025 15:11:46 -0400
Subject: [PATCH] properly implement oauth 2.0

---
 .cursor/rules/dotnet-dev.mdc                  |  75 +++
 AuthServer/Contracts/IAuthCodeRepository.cs   |  73 +++
 .../Contracts/IOAuthClientRepository.cs       |  51 ++
 AuthServer/Contracts/IRefreshTokenService.cs  |   2 +-
 AuthServer/Contracts/IUserRepository.cs       |  33 +
 AuthServer/Controllers/AuthController.cs      | 224 -------
 .../Controllers/OAuthClientController.cs      | 170 ++++++
 AuthServer/Controllers/OAuthController.cs     | 577 ++++++++++++++++++
 .../Exceptions/InvalidClientException.cs      |  17 +
 .../Exceptions/InvalidGrantException.cs       |  17 +
 .../Exceptions/InvalidRequestException.cs     |  17 +
 .../Exceptions/InvalidScopeException.cs       |  16 +
 AuthServer/Exceptions/OAuthException.cs       |  33 +
 .../Middleware/ExceptionHandlingMiddleware.cs |  74 +++
 .../Models/ClientRegistrationRequest.cs       |  36 ++
 AuthServer/Models/GrantType.cs                |  17 +
 AuthServer/Models/LoginResponse.cs            |  26 +-
 AuthServer/Models/OAuthClient.cs              |  50 ++
 AuthServer/Models/RedirectRequest.cs          |  26 +
 AuthServer/Models/TokenRequest.cs             |  53 ++
 AuthServer/Pages/Auth/Login.cshtml            | 105 +++-
 AuthServer/Pages/Auth/Login.cshtml.cs         |  35 +-
 AuthServer/Program.cs                         |  42 +-
 .../AuthenticationService.cs                  |  47 +-
 .../Authentication/InMemoryUserRepository.cs  | 131 ++++
 .../Services/Client/AuthCodeRepository.cs     | 113 ++++
 .../Services/Client/OAuthClientRepository.cs  | 129 ++++
 .../{ => Client}/RedirectUriValidator.cs      |   2 +-
 .../Services/{ => Infrastructure}/Log.cs      |  66 +-
 .../{ => Token}/KeyManagementHealthCheck.cs   |   2 +-
 .../{ => Token}/KeyManagementService.cs       |   2 +-
 .../{ => Token}/RefreshTokenCleanupService.cs |   2 +-
 .../{ => Token}/RefreshTokenService.cs        |   4 +-
 CLAUDE.md                                     |  39 ++
 WeatherApi/Program.cs                         |   4 +-
 WeatherSpa/CLAUDE.md                          |  21 +
 WeatherSpa/src/app.css                        |  79 ++-
 WeatherSpa/src/components/card.css            |   4 +-
 WeatherSpa/src/components/checkbox-group.css  |  16 +-
 WeatherSpa/src/components/checkbox.css        |  35 ++
 WeatherSpa/src/components/checkbox.tsx        |  34 ++
 WeatherSpa/src/components/design-system.ts    |  67 +-
 WeatherSpa/src/components/detail-card.css     |  10 +-
 WeatherSpa/src/components/hero.css            |  96 ++-
 WeatherSpa/src/components/input.css           |  22 +-
 WeatherSpa/src/components/layout.css          |  22 +-
 WeatherSpa/src/components/layout.tsx          |   2 +-
 WeatherSpa/src/components/login-layout.css    |  25 +-
 .../src/components/user-info-banner.tsx       |   7 +-
 WeatherSpa/src/components/weather-card.css    |  15 +-
 WeatherSpa/src/contexts/auth-context.tsx      | 165 ++---
 WeatherSpa/src/index.css                      |  33 +-
 WeatherSpa/src/pages/auth-callback-page.tsx   |  90 ++-
 WeatherSpa/src/pages/forecasts-page.css       |   4 +-
 WeatherSpa/src/pages/forecasts-page.tsx       |   4 +-
 WeatherSpa/src/pages/redirect-login-page.tsx  |  40 +-
 WeatherSpa/src/pages/unauthorized-page.css    |  18 +-
 WeatherSpa/src/services/auth-service.ts       | 211 ++++++-
 WeatherSpa/src/types/index.ts                 |  23 +-
 59 files changed, 2667 insertions(+), 686 deletions(-)
 create mode 100644 .cursor/rules/dotnet-dev.mdc
 create mode 100644 AuthServer/Contracts/IAuthCodeRepository.cs
 create mode 100644 AuthServer/Contracts/IOAuthClientRepository.cs
 create mode 100644 AuthServer/Contracts/IUserRepository.cs
 delete mode 100644 AuthServer/Controllers/AuthController.cs
 create mode 100644 AuthServer/Controllers/OAuthClientController.cs
 create mode 100644 AuthServer/Controllers/OAuthController.cs
 create mode 100644 AuthServer/Exceptions/InvalidClientException.cs
 create mode 100644 AuthServer/Exceptions/InvalidGrantException.cs
 create mode 100644 AuthServer/Exceptions/InvalidRequestException.cs
 create mode 100644 AuthServer/Exceptions/InvalidScopeException.cs
 create mode 100644 AuthServer/Exceptions/OAuthException.cs
 create mode 100644 AuthServer/Middleware/ExceptionHandlingMiddleware.cs
 create mode 100644 AuthServer/Models/ClientRegistrationRequest.cs
 create mode 100644 AuthServer/Models/GrantType.cs
 create mode 100644 AuthServer/Models/OAuthClient.cs
 create mode 100644 AuthServer/Models/TokenRequest.cs
 rename AuthServer/Services/{ => Authentication}/AuthenticationService.cs (67%)
 create mode 100644 AuthServer/Services/Authentication/InMemoryUserRepository.cs
 create mode 100644 AuthServer/Services/Client/AuthCodeRepository.cs
 create mode 100644 AuthServer/Services/Client/OAuthClientRepository.cs
 rename AuthServer/Services/{ => Client}/RedirectUriValidator.cs (98%)
 rename AuthServer/Services/{ => Infrastructure}/Log.cs (60%)
 rename AuthServer/Services/{ => Token}/KeyManagementHealthCheck.cs (97%)
 rename AuthServer/Services/{ => Token}/KeyManagementService.cs (98%)
 rename AuthServer/Services/{ => Token}/RefreshTokenCleanupService.cs (97%)
 rename AuthServer/Services/{ => Token}/RefreshTokenService.cs (97%)
 create mode 100644 CLAUDE.md
 create mode 100644 WeatherSpa/CLAUDE.md
 create mode 100644 WeatherSpa/src/components/checkbox.css
 create mode 100644 WeatherSpa/src/components/checkbox.tsx

diff --git a/.cursor/rules/dotnet-dev.mdc b/.cursor/rules/dotnet-dev.mdc
new file mode 100644
index 0000000..c321bbe
--- /dev/null
+++ b/.cursor/rules/dotnet-dev.mdc
@@ -0,0 +1,75 @@
+---
+description: 
+globs: 
+alwaysApply: true
+---
+
+  # .NET Development Rules
+
+  You are a senior .NET backend developer and an expert in C#, ASP.NET Core, and Entity Framework Core.
+
+  ## Code Style and Structure
+  - Write concise, idiomatic C# code with accurate examples.
+  - Follow .NET and ASP.NET Core conventions and best practices.
+  - Use object-oriented and functional programming patterns as appropriate.
+  - Prefer LINQ and lambda expressions for collection operations.
+  - Use descriptive variable and method names (e.g., 'IsUserSignedIn', 'CalculateTotal').
+  - Structure files according to .NET conventions (Controllers, Models, Services, etc.).
+
+  ## Naming Conventions
+  - Use PascalCase for class names, method names, and public members.
+  - Use camelCase for local variables and private fields.
+  - Use UPPERCASE for constants.
+  - Prefix interface names with "I" (e.g., 'IUserService').
+
+  ## C# and .NET Usage
+  - Use C# 10+ features when appropriate (e.g., record types, pattern matching, null-coalescing assignment).
+  - Leverage built-in ASP.NET Core features and middleware.
+  - Use Entity Framework Core effectively for database operations.
+
+  ## Syntax and Formatting
+  - Follow the C# Coding Conventions (https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions)
+  - Use C#'s expressive syntax (e.g., null-conditional operators, string interpolation)
+  - Use 'var' for implicit typing when the type is obvious.
+
+  ## Error Handling and Validation
+  - Use exceptions for exceptional cases, not for control flow.
+  - Implement proper error logging using built-in .NET logging or a third-party logger.
+  - Use Data Annotations or Fluent Validation for model validation.
+  - Implement global exception handling middleware.
+  - Return appropriate HTTP status codes and consistent error responses.
+
+  ## API Design
+  - Follow RESTful API design principles.
+  - Use attribute routing in controllers.
+  - Implement versioning for your API.
+  - Use action filters for cross-cutting concerns.
+
+  ## Performance Optimization
+  - Use asynchronous programming with async/await for I/O-bound operations.
+  - Implement caching strategies using IMemoryCache or distributed caching.
+  - Use efficient LINQ queries and avoid N+1 query problems.
+  - Implement pagination for large data sets.
+
+  ## Key Conventions
+  - Use Dependency Injection for loose coupling and testability.
+  - Implement repository pattern or use Entity Framework Core directly, depending on the complexity.
+  - Use AutoMapper for object-to-object mapping if needed.
+  - Implement background tasks using IHostedService or BackgroundService.
+
+  ## Testing
+  - Write unit tests using xUnit, NUnit, or MSTest.
+  - Use Moq or NSubstitute for mocking dependencies.
+  - Implement integration tests for API endpoints.
+
+  ## Security
+  - Use Authentication and Authorization middleware.
+  - Implement JWT authentication for stateless API authentication.
+  - Use HTTPS and enforce SSL.
+  - Implement proper CORS policies.
+
+  ## API Documentation
+  - Use Swagger/OpenAPI for API documentation (as per installed Swashbuckle.AspNetCore package).
+  - Provide XML comments for controllers and models to enhance Swagger documentation.
+
+  Follow the official Microsoft documentation and ASP.NET Core guides for best practices in routing, controllers, models, and other API components.
diff --git a/AuthServer/Contracts/IAuthCodeRepository.cs b/AuthServer/Contracts/IAuthCodeRepository.cs
new file mode 100644
index 0000000..8bd7b69
--- /dev/null
+++ b/AuthServer/Contracts/IAuthCodeRepository.cs
@@ -0,0 +1,73 @@
+namespace AuthServer.Contracts;
+
+/// <summary>
+/// Manages authorization codes used in the OAuth code flow
+/// </summary>
+public interface IAuthCodeRepository
+{
+    /// <summary>
+    /// Creates a new authorization code and stores it with the provided data
+    /// </summary>
+    /// <param name="userId">The user ID the code is issued for</param>
+    /// <param name="redirectUri">The redirect URI this code is valid for</param>
+    /// <param name="scopes">The scopes requested for this code</param>
+    /// <param name="codeChallenge">Optional PKCE code challenge for enhanced security</param>
+    /// <param name="codeChallengeMethod">PKCE challenge method - either "S256" (recommended) or "plain"</param>
+    /// <returns>The generated authorization code</returns>
+    public string Create(
+        string userId,
+        string redirectUri,
+        IEnumerable<string> scopes,
+        string? codeChallenge = null,
+        string? codeChallengeMethod = null
+    );
+
+    /// <summary>
+    /// Validates and consumes an authorization code, returning the associated data
+    /// </summary>
+    /// <param name="code">The authorization code to redeem</param>
+    /// <param name="redirectUri">The redirect URI to validate against</param>
+    /// <returns>The data associated with the code, or null if invalid or already consumed</returns>
+    public Task<AuthCodeData?> Consume(string code, string redirectUri);
+}
+
+/// <summary>
+/// Data associated with an authorization code
+/// </summary>
+public class AuthCodeData
+{
+    /// <summary>
+    /// The user ID associated with this code
+    /// </summary>
+    public required string UserId { get; set; }
+
+    /// <summary>
+    /// The redirect URI this code was issued for
+    /// </summary>
+    public required string RedirectUri { get; set; }
+
+    /// <summary>
+    /// The scopes requested with this code
+    /// </summary>
+    public required IEnumerable<string> Scopes { get; set; }
+
+    /// <summary>
+    /// The PKCE code challenge (if provided during authorization)
+    /// </summary>
+    public string? CodeChallenge { get; set; }
+
+    /// <summary>
+    /// The PKCE code challenge method (S256 or plain)
+    /// </summary>
+    public string? CodeChallengeMethod { get; set; }
+
+    /// <summary>
+    /// When this code was created
+    /// </summary>
+    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
+
+    /// <summary>
+    /// When this code expires
+    /// </summary>
+    public DateTime ExpiresAt { get; set; } = DateTime.UtcNow.AddMinutes(10);
+}
diff --git a/AuthServer/Contracts/IOAuthClientRepository.cs b/AuthServer/Contracts/IOAuthClientRepository.cs
new file mode 100644
index 0000000..9008596
--- /dev/null
+++ b/AuthServer/Contracts/IOAuthClientRepository.cs
@@ -0,0 +1,51 @@
+using AuthServer.Models;
+
+namespace AuthServer.Contracts;
+
+/// <summary>
+/// Repository for OAuth client applications
+/// </summary>
+public interface IOAuthClientRepository
+{
+    /// <summary>
+    /// Gets a client by its ID
+    /// </summary>
+    /// <param name="clientId">The client ID</param>
+    /// <returns>The client, or null if not found</returns>
+    public Task<OAuthClient?> GetClientByIdAsync(string clientId);
+
+    /// <summary>
+    /// Creates a new client
+    /// </summary>
+    /// <param name="client">The client to create</param>
+    /// <returns>The created client</returns>
+    public Task<OAuthClient> CreateClientAsync(OAuthClient client);
+
+    /// <summary>
+    /// Updates an existing client
+    /// </summary>
+    /// <param name="client">The client to update</param>
+    /// <returns>True if the client was updated, false otherwise</returns>
+    public Task<bool> UpdateClientAsync(OAuthClient client);
+
+    /// <summary>
+    /// Deletes a client
+    /// </summary>
+    /// <param name="clientId">The client ID</param>
+    /// <returns>True if the client was deleted, false otherwise</returns>
+    public Task<bool> DeleteClientAsync(string clientId);
+
+    /// <summary>
+    /// Gets all clients
+    /// </summary>
+    /// <returns>A list of all clients</returns>
+    public Task<List<OAuthClient>> GetAllClientsAsync();
+
+    /// <summary>
+    /// Validates a redirect URI for a client
+    /// </summary>
+    /// <param name="clientId">The client ID</param>
+    /// <param name="redirectUri">The redirect URI to validate</param>
+    /// <returns>True if the redirect URI is valid for the client, false otherwise</returns>
+    public Task<bool> ValidateRedirectUriAsync(string clientId, string redirectUri);
+}
diff --git a/AuthServer/Contracts/IRefreshTokenService.cs b/AuthServer/Contracts/IRefreshTokenService.cs
index eeb41d3..a88e6a7 100644
--- a/AuthServer/Contracts/IRefreshTokenService.cs
+++ b/AuthServer/Contracts/IRefreshTokenService.cs
@@ -34,7 +34,7 @@ public interface IRefreshTokenService
     /// </summary>
     /// <param name="token">The token to revoke</param>
     /// <returns>True if revoked successfully</returns>
-    public Task<bool> RevokeRefreshToken(string token);
+    public Task<bool> Revoke(string token);
 
     /// <summary>
     /// Revoke all refresh tokens for a specific user
diff --git a/AuthServer/Contracts/IUserRepository.cs b/AuthServer/Contracts/IUserRepository.cs
new file mode 100644
index 0000000..692c6a0
--- /dev/null
+++ b/AuthServer/Contracts/IUserRepository.cs
@@ -0,0 +1,33 @@
+using AuthServer.Models;
+
+namespace AuthServer.Contracts;
+
+/// <summary>
+/// Repository for managing user data
+/// </summary>
+public interface IUserRepository
+{
+    /// <summary>
+    /// Validates credentials and returns a user if valid
+    /// </summary>
+    /// <param name="username">The username to validate</param>
+    /// <param name="password">The password to validate</param>
+    /// <param name="tenant">The tenant to validate for</param>
+    /// <returns>A User object if valid, null otherwise</returns>
+    public Task<User?> ValidateCredentials(string username, string password, string tenant);
+
+    /// <summary>
+    /// Gets a user by their ID
+    /// </summary>
+    /// <param name="userId">The user ID to look up</param>
+    /// <returns>A User object if found, null otherwise</returns>
+    public Task<User?> GetUserById(string userId);
+
+    /// <summary>
+    /// Gets a user by their username in a specific tenant
+    /// </summary>
+    /// <param name="username">The username to look up</param>
+    /// <param name="tenant">The tenant to look in</param>
+    /// <returns>A User object if found, null otherwise</returns>
+    public Task<User?> GetUserByUsername(string username, string tenant);
+}
diff --git a/AuthServer/Controllers/AuthController.cs b/AuthServer/Controllers/AuthController.cs
deleted file mode 100644
index 4c4d9d8..0000000
--- a/AuthServer/Controllers/AuthController.cs
+++ /dev/null
@@ -1,224 +0,0 @@
-using System.Security.Claims;
-using AuthServer.Contracts;
-using AuthServer.Models;
-using AuthServer.Services;
-using Microsoft.AspNetCore.Authorization;
-using Microsoft.AspNetCore.Mvc;
-using Microsoft.IdentityModel.Tokens;
-
-namespace AuthServer.Controllers;
-
-/// <summary>
-/// Authentication controller that provides endpoints for JWT token generation and redirect-based authentication
-/// </summary>
-[ApiController]
-[Produces("application/json")]
-public partial class AuthenticationController(
-    IAuthenticationService authService,
-    IRedirectUriValidator redirectUriValidator,
-    IKeyManagementService keyManagementService,
-    IRefreshTokenService refreshTokenService,
-    TokenConfiguration tokenConfiguration,
-    ILogger<AuthenticationController> logger
-) : ControllerBase
-{
-    /// <summary>
-    /// Authenticates a user and returns a JWT token
-    /// </summary>
-    /// <param name="request">The login credentials and requested scopes</param>
-    /// <returns>A JWT token with the specified scopes and expiration date</returns>
-    /// <response code="200">Returns the JWT token if authentication is successful</response>
-    /// <response code="401">If the credentials are invalid</response>
-    [HttpPost("api/login")]
-    [ProducesResponseType(typeof(LoginResponse), StatusCodes.Status200OK)]
-    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
-    public async Task<IActionResult> Login([FromBody] LoginRequest request)
-    {
-        Log.LoginAttempt(logger, request.Username, request.Tenant);
-
-        var user = await authService.AttemptLogin(
-            request.Username,
-            request.Password,
-            request.Tenant
-        );
-
-        if (user is null)
-        {
-            Log.LoginFailed(logger, request.Username, request.Tenant);
-            return Unauthorized("Invalid username or password");
-        }
-
-        Log.LoginSuccess(logger, user.Username, string.Join(", ", request.Scopes));
-
-        // Generate both access token and refresh token
-        var (accessToken, refreshToken) = authService.GenerateTokenWithRefresh(
-            user,
-            request.Scopes
-        );
-
-        Log.TokenGenerated(
-            logger,
-            user.Username,
-            DateTime.Now.AddHours(tokenConfiguration.ExpiryInHours)
-        );
-
-        return Ok(
-            new LoginResponse
-            {
-                Token = accessToken,
-                Expiration = DateTime.Now.AddHours(tokenConfiguration.ExpiryInHours),
-                RefreshToken = refreshToken.Token,
-                RefreshTokenExpiration = refreshToken.ExpiresAt,
-            }
-        );
-    }
-
-    /// <summary>
-    /// Refreshes an access token using a refresh token
-    /// </summary>
-    /// <param name="request">The refresh token request</param>
-    /// <returns>A new JWT token and refresh token</returns>
-    /// <response code="200">Returns the new JWT token if refresh is successful</response>
-    /// <response code="401">If the refresh token is invalid or expired</response>
-    [HttpPost("api/refresh")]
-    [ProducesResponseType(typeof(LoginResponse), StatusCodes.Status200OK)]
-    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
-    public async Task<IActionResult> RefreshToken([FromBody] RefreshRequest request)
-    {
-        var (newAccessToken, newRefreshToken) = await authService.RefreshToken(
-            request.RefreshToken
-        );
-
-        if (newAccessToken == null || newRefreshToken == null)
-        {
-            return Unauthorized("Invalid or expired refresh token");
-        }
-
-        Log.TokenRefreshed(logger, newRefreshToken.Username);
-
-        return Ok(
-            new LoginResponse
-            {
-                Token = newAccessToken,
-                Expiration = DateTime.Now.AddHours(tokenConfiguration.ExpiryInHours),
-                RefreshToken = newRefreshToken.Token,
-                RefreshTokenExpiration = newRefreshToken.ExpiresAt,
-            }
-        );
-    }
-
-    /// <summary>
-    /// Revokes a refresh token, effectively logging the user out
-    /// </summary>
-    /// <param name="request">The refresh token to revoke</param>
-    /// <returns>Success confirmation</returns>
-    /// <response code="200">The token was successfully revoked</response>
-    /// <response code="400">If the token couldn't be revoked</response>
-    [HttpPost("api/logout")]
-    [ProducesResponseType(StatusCodes.Status200OK)]
-    [ProducesResponseType(StatusCodes.Status400BadRequest)]
-    public async Task<IActionResult> RevokeToken([FromBody] RefreshRequest request)
-    {
-        var result = await refreshTokenService.RevokeRefreshToken(request.RefreshToken);
-
-        return !result
-            ? BadRequest("Invalid refresh token")
-            : Ok(new { Message = "Token revoked successfully" });
-    }
-
-    /// <summary>
-    /// Initiates a redirect-based authentication flow
-    /// </summary>
-    /// <param name="request">Request containing redirect URI, state, optional tenant, and optional scopes</param>
-    /// <returns>Redirects to the login page</returns>
-    /// <response code="302">Redirects to the login page</response>
-    /// <response code="400">If the redirect URI is invalid</response>
-    [HttpGet("api/authorize")]
-    [ProducesResponseType(StatusCodes.Status302Found)]
-    [ProducesResponseType(StatusCodes.Status400BadRequest)]
-    public IActionResult Authorize([FromQuery] RedirectRequest request)
-    {
-        if (
-            string.IsNullOrEmpty(request.RedirectUri)
-            || !redirectUriValidator.Validate(request.RedirectUri)
-        )
-        {
-            Log.RedirectUriInvalid(logger, request.RedirectUri ?? "[null]");
-            return BadRequest("Invalid redirect URI - must match allowed hosts or patterns");
-        }
-
-        HttpContext.Session.SetString("RedirectUri", request.RedirectUri);
-
-        if (!string.IsNullOrEmpty(request.State))
-        {
-            HttpContext.Session.SetString("State", request.State);
-        }
-
-        if (!string.IsNullOrEmpty(request.Tenant))
-        {
-            HttpContext.Session.SetString("Tenant", request.Tenant);
-        }
-
-        if (!string.IsNullOrEmpty(request.Scopes))
-        {
-            HttpContext.Session.SetString("Scopes", request.Scopes);
-        }
-
-        // Redirect to the Razor Page login page
-        return Redirect("/Auth/Login");
-    }
-
-    /// <summary>
-    /// Retrieves information about the currently authenticated user
-    /// </summary>
-    /// <returns>User information extracted from the JWT token claims</returns>
-    /// <response code="200">Returns the user information</response>
-    /// <response code="401">If the user is not authenticated</response>
-    [Authorize]
-    [HttpGet("api/me")]
-    [ProducesResponseType(StatusCodes.Status200OK)]
-    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
-    public IActionResult GetCurrentUser()
-    {
-        var username = User.Identity?.Name;
-
-        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue("sub");
-
-        var tenant = User.FindFirstValue("tenant");
-        var roles = User
-            .Claims.Where(static c => c.Type is ClaimTypes.Role or "role")
-            .Select(static c => c.Value)
-            .ToList();
-
-        var scopes = User
-            .Claims.Where(static c => c.Type == "scope")
-            .Select(static c => c.Value)
-            .ToList();
-
-        return Ok(
-            new
-            {
-                UserId = userId,
-                Username = username,
-                Tenant = tenant,
-                Roles = roles,
-                Scopes = scopes,
-            }
-        );
-    }
-
-    /// <summary>
-    /// Provides the public JSON Web Key Set (JWKS) for token validation
-    /// </summary>
-    /// <returns>A JSON Web Key Set containing the public key used to sign tokens</returns>
-    /// <response code="200">Returns the JWKS</response>
-    [HttpGet(".well-known/jwks.json")]
-    [ProducesResponseType(typeof(JsonWebKeySet), StatusCodes.Status200OK)]
-    public IActionResult GetJsonWebKeySet()
-    {
-        var jwks = new JsonWebKeySet();
-        jwks.Keys.Add(keyManagementService.GetJsonWebKey());
-
-        return Ok(jwks);
-    }
-}
diff --git a/AuthServer/Controllers/OAuthClientController.cs b/AuthServer/Controllers/OAuthClientController.cs
new file mode 100644
index 0000000..7521e2a
--- /dev/null
+++ b/AuthServer/Controllers/OAuthClientController.cs
@@ -0,0 +1,170 @@
+using AuthServer.Contracts;
+using AuthServer.Models;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+
+namespace AuthServer.Controllers;
+
+/// <summary>
+/// Controller for OAuth client registration and management
+/// </summary>
+[ApiController]
+[Route("api/clients")]
+[Produces("application/json")]
+public class OAuthClientController(
+    IOAuthClientRepository clientRepository,
+    ILogger<OAuthClientController> logger
+) : ControllerBase
+{
+    /// <summary>
+    /// Registers a new OAuth client
+    /// </summary>
+    /// <param name="request">The client registration request</param>
+    /// <returns>The registered client</returns>
+    /// <response code="201">Returns the newly created client</response>
+    /// <response code="400">If the request is invalid</response>
+    [HttpPost]
+    [ProducesResponseType(typeof(OAuthClient), StatusCodes.Status201Created)]
+    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
+    public async Task<IActionResult> RegisterClient([FromBody] ClientRegistrationRequest request)
+    {
+        // Validate request
+        if (
+            string.IsNullOrEmpty(request.ClientName)
+            || request.RedirectUris == null
+            || request.RedirectUris.Count == 0
+        )
+        {
+            return BadRequest(
+                new ProblemDetails
+                {
+                    Title = "Invalid Request",
+                    Detail = "Client name and at least one redirect URI are required",
+                    Status = StatusCodes.Status400BadRequest,
+                    Type = "https://tools.ietf.org/html/rfc7591#section-3.2.2",
+                    Extensions = new Dictionary<string, object?>()
+                    {
+                        { "error", "invalid_client_metadata" },
+                    },
+                }
+            );
+        }
+
+        // Create client
+        var client = new OAuthClient
+        {
+            ClientName = request.ClientName,
+            Description = request.Description,
+            RedirectUris = request.RedirectUris,
+            AllowedScopes =
+                request.AllowedScopes.Count != 0
+                    ? request.AllowedScopes
+                    : ["openid", "profile", "email"],
+            IsPublicClient = request.IsPublicClient,
+        };
+
+        try
+        {
+            // Save client
+            var createdClient = await clientRepository.CreateClientAsync(client);
+
+            logger.LogInformation(
+                "Client registered: {ClientId} - {ClientName}",
+                createdClient.ClientId,
+                createdClient.ClientName
+            );
+
+            // Return client credentials (only shown once)
+            return CreatedAtAction(
+                nameof(GetClient),
+                new { clientId = createdClient.ClientId },
+                new
+                {
+                    client_id = createdClient.ClientId,
+                    client_name = createdClient.ClientName,
+                    redirect_uris = createdClient.RedirectUris,
+                    allowed_scopes = createdClient.AllowedScopes,
+                    is_public_client = createdClient.IsPublicClient,
+                }
+            );
+        }
+        catch (InvalidOperationException ex)
+        {
+            return BadRequest(
+                new ProblemDetails
+                {
+                    Title = "Client Already Exists",
+                    Detail = ex.Message,
+                    Status = StatusCodes.Status400BadRequest,
+                    Type = "https://tools.ietf.org/html/rfc7591#section-3.2.2",
+                    Extensions = new Dictionary<string, object?>()
+                    {
+                        { "error", "invalid_client_metadata" },
+                    },
+                }
+            );
+        }
+    }
+
+    /// <summary>
+    /// Gets a client by ID
+    /// </summary>
+    /// <param name="clientId">The client ID</param>
+    /// <returns>The client</returns>
+    /// <response code="200">Returns the client</response>
+    /// <response code="404">If the client is not found</response>
+    [HttpGet("{clientId}")]
+    [ProducesResponseType(typeof(OAuthClient), StatusCodes.Status200OK)]
+    [ProducesResponseType(StatusCodes.Status404NotFound)]
+    public async Task<IActionResult> GetClient(string clientId)
+    {
+        var client = await clientRepository.GetClientByIdAsync(clientId);
+        if (client == null)
+        {
+            return NotFound();
+        }
+
+        // Don't return sensitive information
+        return Ok(
+            new
+            {
+                client_id = client.ClientId,
+                client_name = client.ClientName,
+                description = client.Description,
+                redirect_uris = client.RedirectUris,
+                allowed_scopes = client.AllowedScopes,
+                is_active = client.IsActive,
+                is_public_client = client.IsPublicClient,
+                created_at = client.CreatedAt,
+            }
+        );
+    }
+
+    /// <summary>
+    /// Gets all clients
+    /// </summary>
+    /// <returns>A list of clients</returns>
+    /// <response code="200">Returns the list of clients</response>
+    [HttpGet]
+    [Authorize(Roles = "Admin")] // Only admins can list all clients
+    [ProducesResponseType(typeof(IEnumerable<object>), StatusCodes.Status200OK)]
+    public async Task<IActionResult> GetAllClients()
+    {
+        var clients = await clientRepository.GetAllClientsAsync();
+
+        // Don't return sensitive information
+        var clientList = clients.Select(static client => new
+        {
+            client_id = client.ClientId,
+            client_name = client.ClientName,
+            description = client.Description,
+            redirect_uris = client.RedirectUris,
+            allowed_scopes = client.AllowedScopes,
+            is_active = client.IsActive,
+            is_public_client = client.IsPublicClient,
+            created_at = client.CreatedAt,
+        });
+
+        return Ok(clientList);
+    }
+}
diff --git a/AuthServer/Controllers/OAuthController.cs b/AuthServer/Controllers/OAuthController.cs
new file mode 100644
index 0000000..87abaae
--- /dev/null
+++ b/AuthServer/Controllers/OAuthController.cs
@@ -0,0 +1,577 @@
+using System.Security.Claims;
+using AuthServer.Contracts;
+using AuthServer.Exceptions;
+using AuthServer.Models;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Microsoft.IdentityModel.Tokens;
+
+namespace AuthServer.Controllers;
+
+/// <summary>
+/// Controller for standard OAuth 2.0 and OpenID Connect endpoints
+/// </summary>
+[ApiController]
+[Route("oauth")]
+[Produces("application/json")]
+public class OAuthController(
+    IAuthenticationService authService,
+    IRedirectUriValidator redirectUriValidator,
+    IKeyManagementService keyManagementService,
+    IAuthCodeRepository authCodeRepository,
+    IUserRepository userRepository,
+    IOAuthClientRepository clientRepository,
+    TokenConfiguration tokenConfiguration,
+    IRefreshTokenService refreshTokenService,
+    ILogger<OAuthController> logger
+) : ControllerBase
+{
+    private static readonly string[] _supportedResponseTypes = ["code"];
+    private static readonly string[] _supportedSubjectTypes = ["public"];
+    private static readonly string[] _supportedSigningAlgorithms = ["RS256"];
+    private static readonly string[] _supportedScopes =
+    [
+        "openid",
+        "profile",
+        "email",
+        "weather.read",
+    ];
+    private static readonly string[] _supportedTokenEndpointAuthMethods = ["none"];
+    private static readonly string[] _supportedCodeChallengeMethods = ["S256", "plain"];
+    private static readonly string[] _supportedClaims =
+    [
+        "sub",
+        "iss",
+        "aud",
+        "exp",
+        "iat",
+        "name",
+        "email",
+        "role",
+        "scope",
+        "tenant",
+    ];
+
+    /// <summary>
+    /// OAuth 2.0 Authorization Endpoint
+    /// </summary>
+    /// <returns>Redirects to the login page</returns>
+    /// <response code="302">Redirects to the login page</response>
+    /// <response code="400">If the request is invalid</response>
+    [HttpGet("authorize")]
+    [ProducesResponseType(StatusCodes.Status302Found)]
+    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
+    public async Task<IActionResult> Authorize(
+        [FromQuery(Name = "client_id")] string? clientId,
+        [FromQuery(Name = "redirect_uri")] string? redirectUri,
+        [FromQuery(Name = "state")] string? state,
+        [FromQuery(Name = "response_type")] string? responseType,
+        [FromQuery(Name = "scope")] string? scope,
+        [FromQuery(Name = "tenant")] string? tenant,
+        [FromQuery(Name = "code_challenge")] string? codeChallenge,
+        [FromQuery(Name = "code_challenge_method")] string? codeChallengeMethod,
+        [FromQuery(Name = "nonce")] string? nonce
+    )
+    {
+        // Log the incoming request parameters
+        logger.LogInformation(
+            "Authorization request received: client_id={ClientId}, redirect_uri={RedirectUri}, state={State}, scope={Scope}, response_type={ResponseType}",
+            clientId ?? "[null]",
+            redirectUri ?? "[null]",
+            state ?? "[null]",
+            scope ?? "[null]",
+            responseType ?? "[null]"
+        );
+
+        // Validate required parameters
+        if (string.IsNullOrEmpty(clientId))
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "client_id is required",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+        }
+
+        if (string.IsNullOrEmpty(redirectUri))
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "redirect_uri is required",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+        }
+
+        if (string.IsNullOrEmpty(responseType))
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "response_type is required",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+        }
+
+        // Validate response type
+        if (responseType != "code")
+        {
+            throw new InvalidRequestException(
+                "Unsupported Response Type",
+                "Only 'code' response type is supported",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+        }
+
+        // Validate client
+        var client =
+            await clientRepository.GetClientByIdAsync(clientId)
+            ?? throw new InvalidClientException(
+                "Invalid Client",
+                "Invalid client_id",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+
+        // Validate redirect URI
+        if (
+            !redirectUriValidator.Validate(redirectUri)
+            || !client.RedirectUris.Contains(redirectUri)
+        )
+        {
+            logger.LogWarning("Invalid redirect URI: {RedirectUri}", redirectUri);
+            throw new InvalidRequestException(
+                "Invalid Redirect URI",
+                "Invalid redirect URI - must match allowed hosts or patterns",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+        }
+
+        // Validate scopes
+        var requestedScopes = string.IsNullOrEmpty(scope)
+            ? []
+            : scope.Split(' ', StringSplitOptions.RemoveEmptyEntries);
+
+        if (!client.AllowedScopes.ToHashSet().IsSupersetOf(requestedScopes.ToList()))
+        {
+            throw new InvalidScopeException(
+                "Invalid Scope",
+                "Requested scopes are not allowed for this client",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.2.1"
+            );
+        }
+
+        // Store OAuth 2.0 parameters in session
+        HttpContext.Session.SetString("RedirectUri", redirectUri);
+        HttpContext.Session.SetString("ClientId", clientId);
+        HttpContext.Session.SetString("ResponseType", responseType);
+
+        if (!string.IsNullOrEmpty(state))
+        {
+            HttpContext.Session.SetString("State", state);
+        }
+
+        if (!string.IsNullOrEmpty(tenant))
+        {
+            HttpContext.Session.SetString("Tenant", tenant);
+        }
+
+        if (!string.IsNullOrEmpty(scope))
+        {
+            HttpContext.Session.SetString("Scopes", scope);
+        }
+
+        if (!string.IsNullOrEmpty(nonce))
+        {
+            HttpContext.Session.SetString("Nonce", nonce);
+        }
+
+        // Store PKCE parameters if provided
+        if (!string.IsNullOrEmpty(codeChallenge))
+        {
+            HttpContext.Session.SetString("CodeChallenge", codeChallenge);
+
+            if (!string.IsNullOrEmpty(codeChallengeMethod))
+            {
+                HttpContext.Session.SetString("CodeChallengeMethod", codeChallengeMethod);
+            }
+            else
+            {
+                // Default to S256 if not specified
+                HttpContext.Session.SetString("CodeChallengeMethod", "S256");
+            }
+        }
+
+        // Redirect to the Razor Page login page
+        return Redirect("/Auth/Login");
+    }
+
+    /// <summary>
+    /// OAuth 2.0 Token Endpoint
+    /// </summary>
+    /// <returns>A JWT token with a refresh token</returns>
+    /// <response code="200">Returns the JWT token if exchange is successful</response>
+    /// <response code="400">If the code/refresh token is invalid</response>
+    [HttpPost("token")]
+    [Consumes("application/x-www-form-urlencoded")]
+    [Produces("application/json")]
+    [ProducesResponseType(typeof(LoginResponse), StatusCodes.Status200OK, "application/json")]
+    [ProducesResponseType(
+        typeof(ProblemDetails),
+        StatusCodes.Status400BadRequest,
+        "application/json"
+    )]
+    [ProducesResponseType(
+        typeof(ProblemDetails),
+        StatusCodes.Status401Unauthorized,
+        "application/json"
+    )]
+    public async Task<IActionResult> Token(
+        [FromForm(Name = "grant_type")] string grantType,
+        [FromForm(Name = "code")] string? code,
+        [FromForm(Name = "redirect_uri")] string? redirectUri,
+        [FromForm(Name = "refresh_token")] string? refreshToken,
+        [FromForm(Name = "client_id")] string? clientId,
+        [FromForm(Name = "client_secret")] string? clientSecret,
+        [FromForm(Name = "code_verifier")] string? codeVerifier
+    )
+    {
+        // Validate content type
+        if (!Request.HasFormContentType)
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "Content-Type must be application/x-www-form-urlencoded",
+                "https://tools.ietf.org/html/rfc6749#section-4.1.3"
+            );
+        }
+
+        // Log the raw form data
+        logger.LogInformation(
+            "Raw form data received: {FormData}",
+            string.Join(", ", Request.Form.Select(f => $"{f.Key}={f.Value}"))
+        );
+
+        // Create a TokenRequest from the form parameters
+        var request = new TokenRequest
+        {
+            GrantType = grantType,
+            Code = code,
+            RedirectUri = redirectUri,
+            RefreshToken = refreshToken,
+            ClientId = clientId,
+            ClientSecret = clientSecret,
+            CodeVerifier = codeVerifier,
+        };
+
+        // Log the incoming request
+        logger.LogInformation(
+            "Token request received: grant_type={GrantType}, code={Code}, redirect_uri={RedirectUri}, refresh_token={RefreshToken}",
+            request.GrantType,
+            request.Code ?? "[null]",
+            request.RedirectUri ?? "[null]",
+            request.RefreshToken ?? "[null]"
+        );
+
+        var parsedGrantType = request.GrantType switch
+        {
+            "authorization_code" => GrantType.AuthorizationCode,
+            "refresh_token" => GrantType.RefreshToken,
+            _ => throw new InvalidRequestException(
+                "Unsupported Grant Type",
+                "Supported grant types are 'authorization_code' and 'refresh_token'",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            ),
+        };
+
+        return parsedGrantType switch
+        {
+            GrantType.AuthorizationCode => await HandleAuthorizationCodeGrant(request),
+            GrantType.RefreshToken => await HandleRefreshTokenGrant(request),
+            _ => throw new InvalidRequestException(
+                "Unsupported Grant Type",
+                "Supported grant types are 'authorization_code' and 'refresh_token'",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            ),
+        };
+    }
+
+    /// <summary>
+    /// OpenID Connect UserInfo Endpoint
+    /// </summary>
+    /// <returns>User information extracted from the JWT token claims</returns>
+    /// <response code="200">Returns the user information</response>
+    /// <response code="401">If the user is not authenticated</response>
+    [Authorize]
+    [HttpGet("userinfo")]
+    [ProducesResponseType(StatusCodes.Status200OK)]
+    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
+    public IActionResult UserInfo()
+    {
+        var username = User.Identity?.Name;
+        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier) ?? User.FindFirstValue("sub");
+        var tenant = User.FindFirstValue("tenant");
+        var roles = User
+            .Claims.Where(static c => c.Type is ClaimTypes.Role or "role")
+            .Select(static c => c.Value)
+            .ToList();
+        var scopes = User
+            .Claims.Where(static c => c.Type == "scope")
+            .Select(static c => c.Value)
+            .ToList();
+
+        return Ok(
+            new
+            {
+                UserId = userId,
+                Username = username,
+                Tenant = tenant,
+                Roles = roles,
+                Scopes = scopes,
+            }
+        );
+    }
+
+    /// <summary>
+    /// OpenID Connect JWKS Endpoint
+    /// </summary>
+    /// <returns>A JSON Web Key Set containing the public key used to sign tokens</returns>
+    /// <response code="200">Returns the JWKS</response>
+    [HttpGet("/.well-known/jwks.json")]
+    [ProducesResponseType(typeof(JsonWebKeySet), StatusCodes.Status200OK)]
+    public IActionResult GetJsonWebKeySet()
+    {
+        var jwks = new JsonWebKeySet();
+        jwks.Keys.Add(keyManagementService.GetJsonWebKey());
+
+        return Ok(jwks);
+    }
+
+    /// <summary>
+    /// OpenID Connect Discovery Document
+    /// </summary>
+    /// <returns>OpenID Connect configuration</returns>
+    /// <response code="200">Returns the OpenID Connect configuration</response>
+    [HttpGet("/.well-known/openid-configuration")]
+    [ProducesResponseType(StatusCodes.Status200OK)]
+    public IActionResult GetOpenIdConfiguration()
+    {
+        var baseUrl = $"{Request.Scheme}://{Request.Host}";
+
+        return Ok(
+            new
+            {
+                issuer = baseUrl,
+                authorization_endpoint = $"{baseUrl}/oauth/authorize",
+                token_endpoint = $"{baseUrl}/oauth/token",
+                userinfo_endpoint = $"{baseUrl}/oauth/userinfo",
+                jwks_uri = $"{baseUrl}/oauth/.well-known/jwks.json",
+                response_types_supported = _supportedResponseTypes,
+                subject_types_supported = _supportedSubjectTypes,
+                id_token_signing_alg_values_supported = _supportedSigningAlgorithms,
+                scopes_supported = _supportedScopes,
+                token_endpoint_auth_methods_supported = _supportedTokenEndpointAuthMethods,
+                claims_supported = _supportedClaims,
+                code_challenge_methods_supported = _supportedCodeChallengeMethods,
+            }
+        );
+    }
+
+    /// <summary>
+    /// Handles the authorization_code grant type
+    /// </summary>
+    private async Task<IActionResult> HandleAuthorizationCodeGrant(TokenRequest request)
+    {
+        if (string.IsNullOrEmpty(request.Code) || string.IsNullOrEmpty(request.RedirectUri))
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "Code and redirect_uri are required for authorization_code grant type",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            );
+        }
+
+        var codeData =
+            await authCodeRepository.Consume(request.Code, request.RedirectUri)
+            ?? throw new InvalidGrantException(
+                "Invalid Grant",
+                "Authorization code is invalid or expired",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            );
+
+        if (!string.IsNullOrEmpty(codeData.CodeChallenge))
+        {
+            if (string.IsNullOrEmpty(request.CodeVerifier))
+            {
+                throw new InvalidRequestException(
+                    "Invalid Request",
+                    "Code verifier is required when PKCE was used in the authorization request",
+                    "https://tools.ietf.org/html/rfc6749#section-5.2"
+                );
+            }
+
+            if (
+                !VerifyPkceCodeVerifier(
+                    request.CodeVerifier,
+                    codeData.CodeChallenge,
+                    codeData.CodeChallengeMethod
+                )
+            )
+            {
+                throw new InvalidGrantException(
+                    "Invalid Grant",
+                    "PKCE verification failed - code_verifier is invalid",
+                    "https://tools.ietf.org/html/rfc6749#section-5.2"
+                );
+            }
+        }
+
+        var user =
+            await userRepository.GetUserById(codeData.UserId)
+            ?? throw new InvalidGrantException(
+                "Invalid Grant",
+                "User associated with the authorization code could not be found",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            );
+
+        var (accessToken, refreshToken) = authService.GenerateTokenWithRefresh(
+            user,
+            codeData.Scopes.ToList()
+        );
+
+        return Ok(
+            new LoginResponse
+            {
+                Token = accessToken,
+                Expiration = DateTime.Now.AddHours(tokenConfiguration.ExpiryInHours),
+                RefreshToken = refreshToken.Token,
+                RefreshTokenExpiration = refreshToken.ExpiresAt,
+                Scope = string.Join(" ", codeData.Scopes),
+            }
+        );
+    }
+
+    /// <summary>
+    /// Handles the refresh_token grant type
+    /// </summary>
+    private async Task<IActionResult> HandleRefreshTokenGrant(TokenRequest request)
+    {
+        if (string.IsNullOrEmpty(request.RefreshToken))
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "Refresh token is required for refresh_token grant type",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            );
+        }
+
+        var (newAccessToken, newRefreshToken) = await authService.RefreshToken(
+            request.RefreshToken
+        );
+
+        if (newAccessToken is null || newRefreshToken is null)
+        {
+            throw new InvalidGrantException(
+                "Invalid Grant",
+                "Invalid or expired refresh token",
+                "https://tools.ietf.org/html/rfc6749#section-5.2"
+            );
+        }
+
+        logger.LogInformation("Token refreshed for user: {Username}", newRefreshToken.Username);
+
+        return Ok(
+            new LoginResponse
+            {
+                Token = newAccessToken,
+                Expiration = DateTime.Now.AddHours(tokenConfiguration.ExpiryInHours),
+                RefreshToken = newRefreshToken.Token,
+                RefreshTokenExpiration = newRefreshToken.ExpiresAt,
+            }
+        );
+    }
+
+    /// <summary>
+    /// Verifies a PKCE code_verifier against the stored code_challenge
+    /// </summary>
+    private static bool VerifyPkceCodeVerifier(
+        string codeVerifier,
+        string codeChallenge,
+        string? codeChallengeMethod
+    )
+    {
+        // S256 is the default method if not specified
+        codeChallengeMethod ??= "S256";
+
+        if (codeChallengeMethod.Equals("S256", StringComparison.OrdinalIgnoreCase))
+        {
+            // SHA-256 transformation
+            var verifierBytes = System.Text.Encoding.UTF8.GetBytes(codeVerifier);
+            var challengeBytes = System.Security.Cryptography.SHA256.HashData(verifierBytes);
+            var computedChallenge = Microsoft.AspNetCore.WebUtilities.WebEncoders.Base64UrlEncode(
+                challengeBytes
+            );
+
+            return computedChallenge == codeChallenge;
+        }
+        else if (codeChallengeMethod.Equals("plain", StringComparison.OrdinalIgnoreCase))
+        {
+            // Plain method - direct comparison
+            return codeVerifier == codeChallenge;
+        }
+
+        // Unsupported challenge method
+        return false;
+    }
+
+    /// <summary>
+    /// OAuth 2.0 Token Revocation Endpoint
+    /// </summary>
+    /// <returns>Success response</returns>
+    /// <response code="200">Token was successfully revoked or was already invalid</response>
+    /// <response code="400">If the request is invalid</response>
+    [HttpPost("revoke")]
+    [Consumes("application/x-www-form-urlencoded")]
+    [Produces("application/json")]
+    [ProducesResponseType(StatusCodes.Status200OK)]
+    [ProducesResponseType(typeof(ProblemDetails), StatusCodes.Status400BadRequest)]
+    public async Task<IActionResult> RevokeToken(
+        [FromForm(Name = "token")] string token,
+        [FromForm(Name = "token_type_hint")] string? tokenTypeHint
+    )
+    {
+        // Validate content type
+        if (!Request.HasFormContentType)
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "Content-Type must be application/x-www-form-urlencoded",
+                "https://tools.ietf.org/html/rfc7009#section-2.1"
+            );
+        }
+
+        // Validate required parameters
+        if (string.IsNullOrEmpty(token))
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "token parameter is required",
+                "https://tools.ietf.org/html/rfc7009#section-2.1"
+            );
+        }
+
+        // If token_type_hint is provided, validate it
+        if (!string.IsNullOrEmpty(tokenTypeHint) && tokenTypeHint != "refresh_token")
+        {
+            throw new InvalidRequestException(
+                "Invalid Request",
+                "Only refresh_token revocation is supported",
+                "https://tools.ietf.org/html/rfc7009#section-2.1"
+            );
+        }
+
+        // Try to revoke the token
+        _ = await refreshTokenService.Revoke(token);
+
+        // According to RFC 7009, we should return 200 OK even if the token was invalid
+        logger.LogInformation("Token revocation request processed");
+        return Ok();
+    }
+}
diff --git a/AuthServer/Exceptions/InvalidClientException.cs b/AuthServer/Exceptions/InvalidClientException.cs
new file mode 100644
index 0000000..bb6440b
--- /dev/null
+++ b/AuthServer/Exceptions/InvalidClientException.cs
@@ -0,0 +1,17 @@
+using System.Net;
+
+namespace AuthServer.Exceptions;
+
+/// <summary>
+/// Client authentication failed (e.g., unknown client, no client authentication included,
+/// or unsupported authentication method).
+/// </summary>
+public class InvalidClientException(
+    string? message = null,
+    string? errorDescription = null,
+    string? errorUri = null
+) : OAuthException(message, errorDescription, errorUri)
+{
+    public override string ErrorCode => "invalid_client";
+    public override HttpStatusCode StatusCode => HttpStatusCode.Unauthorized;
+}
diff --git a/AuthServer/Exceptions/InvalidGrantException.cs b/AuthServer/Exceptions/InvalidGrantException.cs
new file mode 100644
index 0000000..88277b5
--- /dev/null
+++ b/AuthServer/Exceptions/InvalidGrantException.cs
@@ -0,0 +1,17 @@
+using System.Net;
+
+namespace AuthServer.Exceptions;
+
+/// <summary>
+/// The provided authorization grant or refresh token is invalid, expired, revoked,
+/// does not match the redirection URI used in the authorization request, or was issued to another client.
+/// </summary>
+public class InvalidGrantException(
+    string? message = null,
+    string? errorDescription = null,
+    string? errorUri = null
+) : OAuthException(message, errorDescription, errorUri)
+{
+    public override string ErrorCode => "invalid_grant";
+    public override HttpStatusCode StatusCode => HttpStatusCode.BadRequest;
+}
diff --git a/AuthServer/Exceptions/InvalidRequestException.cs b/AuthServer/Exceptions/InvalidRequestException.cs
new file mode 100644
index 0000000..4a65ccd
--- /dev/null
+++ b/AuthServer/Exceptions/InvalidRequestException.cs
@@ -0,0 +1,17 @@
+using System.Net;
+
+namespace AuthServer.Exceptions;
+
+/// <summary>
+/// The request is missing a required parameter, includes an unsupported parameter value,
+/// or is otherwise malformed.
+/// </summary>
+public class InvalidRequestException(
+    string? message = null,
+    string? errorDescription = null,
+    string? errorUri = null
+) : OAuthException(message, errorDescription, errorUri)
+{
+    public override string ErrorCode => "invalid_request";
+    public override HttpStatusCode StatusCode => HttpStatusCode.BadRequest;
+}
diff --git a/AuthServer/Exceptions/InvalidScopeException.cs b/AuthServer/Exceptions/InvalidScopeException.cs
new file mode 100644
index 0000000..5097dd5
--- /dev/null
+++ b/AuthServer/Exceptions/InvalidScopeException.cs
@@ -0,0 +1,16 @@
+using System.Net;
+
+namespace AuthServer.Exceptions;
+
+/// <summary>
+/// The requested scope is invalid, unknown, or malformed.
+/// </summary>
+public class InvalidScopeException(
+    string? message = null,
+    string? errorDescription = null,
+    string? errorUri = null
+) : OAuthException(message, errorDescription, errorUri)
+{
+    public override string ErrorCode => "invalid_scope";
+    public override HttpStatusCode StatusCode => HttpStatusCode.BadRequest;
+}
diff --git a/AuthServer/Exceptions/OAuthException.cs b/AuthServer/Exceptions/OAuthException.cs
new file mode 100644
index 0000000..223a26a
--- /dev/null
+++ b/AuthServer/Exceptions/OAuthException.cs
@@ -0,0 +1,33 @@
+using System.Net;
+
+namespace AuthServer.Exceptions;
+
+/// <summary>
+/// Base class for all OAuth 2.0 related exceptions
+/// </summary>
+public abstract class OAuthException(
+    string? message = null,
+    string? errorDescription = null,
+    string? errorUri = null
+) : Exception(message)
+{
+    /// <summary>
+    /// The OAuth 2.0 error code as defined in RFC 6749
+    /// </summary>
+    public abstract string ErrorCode { get; }
+
+    /// <summary>
+    /// The HTTP status code to return
+    /// </summary>
+    public abstract HttpStatusCode StatusCode { get; }
+
+    /// <summary>
+    /// Optional error description
+    /// </summary>
+    public string? ErrorDescription { get; } = errorDescription;
+
+    /// <summary>
+    /// Optional error URI
+    /// </summary>
+    public string? ErrorUri { get; } = errorUri;
+}
diff --git a/AuthServer/Middleware/ExceptionHandlingMiddleware.cs b/AuthServer/Middleware/ExceptionHandlingMiddleware.cs
new file mode 100644
index 0000000..a9eb7c6
--- /dev/null
+++ b/AuthServer/Middleware/ExceptionHandlingMiddleware.cs
@@ -0,0 +1,74 @@
+using System.Net;
+using System.Text.Json;
+using AuthServer.Exceptions;
+using Microsoft.AspNetCore.Mvc;
+
+namespace AuthServer.Middleware;
+
+/// <summary>
+/// Middleware that handles exceptions and converts them to ProblemDetails responses
+/// </summary>
+public class ExceptionHandlingMiddleware(
+    RequestDelegate next,
+    ILogger<ExceptionHandlingMiddleware> logger
+)
+{
+    public async Task InvokeAsync(HttpContext context)
+    {
+        try
+        {
+            await next(context);
+        }
+        catch (OAuthException ex)
+        {
+            logger.LogWarning(ex, "OAuth error occurred: {ErrorCode}", ex.ErrorCode);
+            await HandleOAuthExceptionAsync(context, ex);
+        }
+        catch (Exception ex)
+        {
+            logger.LogError(ex, "An unhandled exception occurred");
+            await HandleExceptionAsync(context);
+        }
+    }
+
+    private static async Task HandleOAuthExceptionAsync(
+        HttpContext context,
+        OAuthException exception
+    )
+    {
+        context.Response.StatusCode = (int)exception.StatusCode;
+        context.Response.ContentType = "application/json";
+
+        var problemDetails = new ProblemDetails
+        {
+            Status = (int)exception.StatusCode,
+            Title = exception.Message,
+            Type = $"https://tools.ietf.org/html/rfc6749#section-5.2",
+            Extensions = new Dictionary<string, object?>
+            {
+                { "error", exception.ErrorCode },
+                { "error_description", exception.ErrorDescription },
+                { "error_uri", exception.ErrorUri },
+            },
+        };
+
+        var json = JsonSerializer.Serialize(problemDetails);
+        await context.Response.WriteAsync(json);
+    }
+
+    private static async Task HandleExceptionAsync(HttpContext context)
+    {
+        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
+        context.Response.ContentType = "application/json";
+
+        var problemDetails = new ProblemDetails
+        {
+            Status = (int)HttpStatusCode.InternalServerError,
+            Title = "An error occurred while processing your request.",
+            Type = "https://tools.ietf.org/html/rfc7231#section-6.6.1",
+        };
+
+        var json = JsonSerializer.Serialize(problemDetails);
+        await context.Response.WriteAsync(json);
+    }
+}
diff --git a/AuthServer/Models/ClientRegistrationRequest.cs b/AuthServer/Models/ClientRegistrationRequest.cs
new file mode 100644
index 0000000..f53aaac
--- /dev/null
+++ b/AuthServer/Models/ClientRegistrationRequest.cs
@@ -0,0 +1,36 @@
+using System.ComponentModel.DataAnnotations;
+
+namespace AuthServer.Models;
+
+/// <summary>
+/// Request model for client registration
+/// </summary>
+public class ClientRegistrationRequest
+{
+    /// <summary>
+    /// The name of the client application
+    /// </summary>
+    [Required]
+    public string ClientName { get; set; } = string.Empty;
+
+    /// <summary>
+    /// A description of the client application
+    /// </summary>
+    public string? Description { get; set; }
+
+    /// <summary>
+    /// The list of redirect URIs allowed for this client
+    /// </summary>
+    [Required]
+    public List<string> RedirectUris { get; set; } = [];
+
+    /// <summary>
+    /// The list of scopes this client is allowed to request
+    /// </summary>
+    public List<string> AllowedScopes { get; set; } = [];
+
+    /// <summary>
+    /// Whether this is a public client (like a SPA) that cannot securely store a client secret
+    /// </summary>
+    public bool IsPublicClient { get; set; } = true;
+}
diff --git a/AuthServer/Models/GrantType.cs b/AuthServer/Models/GrantType.cs
new file mode 100644
index 0000000..797e325
--- /dev/null
+++ b/AuthServer/Models/GrantType.cs
@@ -0,0 +1,17 @@
+namespace AuthServer.Models;
+
+/// <summary>
+/// Supported OAuth 2.0 grant types
+/// </summary>
+public enum GrantType
+{
+    /// <summary>
+    /// Authorization code grant - exchange a code for tokens
+    /// </summary>
+    AuthorizationCode,
+
+    /// <summary>
+    /// Refresh token grant - exchange a refresh token for a new access token
+    /// </summary>
+    RefreshToken,
+}
diff --git a/AuthServer/Models/LoginResponse.cs b/AuthServer/Models/LoginResponse.cs
index 7baef52..bdb9a62 100644
--- a/AuthServer/Models/LoginResponse.cs
+++ b/AuthServer/Models/LoginResponse.cs
@@ -1,31 +1,43 @@
+using System.Text.Json.Serialization;
+
 namespace AuthServer.Models;
 
 /// <summary>
-/// Response model containing the JWT token, refresh token, and expiration dates
+/// Response model for successful authentication
 /// </summary>
 public class LoginResponse
 {
     /// <summary>
-    /// The JWT token string
+    /// The JWT access token
     /// </summary>
     /// <example>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...</example>
+    [JsonPropertyName("access_token")]
     public string Token { get; set; } = string.Empty;
 
     /// <summary>
-    /// The expiration date and time of the token
+    /// When the access token expires
     /// </summary>
     /// <example>2025-03-30T14:30:00Z</example>
+    [JsonPropertyName("expires_in")]
     public DateTime Expiration { get; set; }
 
     /// <summary>
-    /// The refresh token string
+    /// The refresh token
     /// </summary>
     /// <example>6fd9a3f8-0e2b-4870-8567-7c5b09a8f267</example>
-    public string? RefreshToken { get; set; }
+    [JsonPropertyName("refresh_token")]
+    public string RefreshToken { get; set; } = string.Empty;
 
     /// <summary>
-    /// The expiration date and time of the refresh token
+    /// When the refresh token expires
     /// </summary>
     /// <example>2025-04-30T14:30:00Z</example>
-    public DateTime? RefreshTokenExpiration { get; set; }
+    [JsonPropertyName("refresh_token_expires_in")]
+    public DateTime RefreshTokenExpiration { get; set; }
+
+    /// <summary>
+    /// The granted scopes, space-separated
+    /// </summary>
+    [JsonPropertyName("scope")]
+    public string? Scope { get; set; }
 }
diff --git a/AuthServer/Models/OAuthClient.cs b/AuthServer/Models/OAuthClient.cs
new file mode 100644
index 0000000..2395aaf
--- /dev/null
+++ b/AuthServer/Models/OAuthClient.cs
@@ -0,0 +1,50 @@
+using System.ComponentModel.DataAnnotations;
+
+namespace AuthServer.Models;
+
+/// <summary>
+/// Represents an OAuth client application
+/// </summary>
+public class OAuthClient
+{
+    /// <summary>
+    /// The unique identifier for the client
+    /// </summary>
+    public string ClientId { get; set; } = Guid.NewGuid().ToString("N");
+
+    /// <summary>
+    /// The name of the client application
+    /// </summary>
+    [Required]
+    public string ClientName { get; set; } = string.Empty;
+
+    /// <summary>
+    /// A description of the client application
+    /// </summary>
+    public string? Description { get; set; }
+
+    /// <summary>
+    /// The list of redirect URIs allowed for this client
+    /// </summary>
+    public List<string> RedirectUris { get; set; } = [];
+
+    /// <summary>
+    /// The list of scopes this client is allowed to request
+    /// </summary>
+    public List<string> AllowedScopes { get; set; } = [];
+
+    /// <summary>
+    /// Whether this client is active
+    /// </summary>
+    public bool IsActive { get; set; } = true;
+
+    /// <summary>
+    /// Whether this is a public client (like a SPA) that cannot securely store a client secret
+    /// </summary>
+    public bool IsPublicClient { get; set; } = true;
+
+    /// <summary>
+    /// When this client was created
+    /// </summary>
+    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
+}
diff --git a/AuthServer/Models/RedirectRequest.cs b/AuthServer/Models/RedirectRequest.cs
index 670bdc6..0d08d3b 100644
--- a/AuthServer/Models/RedirectRequest.cs
+++ b/AuthServer/Models/RedirectRequest.cs
@@ -1,4 +1,5 @@
 using System.ComponentModel.DataAnnotations;
+using System.Text.Json.Serialization;
 
 namespace AuthServer.Models;
 
@@ -7,28 +8,53 @@ namespace AuthServer.Models;
 /// </summary>
 public class RedirectRequest
 {
+    /// <summary>
+    /// The client identifier issued to the client during the registration process
+    /// </summary>
+    /// <example>weather-spa</example>
+    [JsonPropertyName("client_id")]
+    public string? ClientId { get; set; }
+
     /// <summary>
     /// The URI to redirect back to after successful authentication
     /// </summary>
     /// <example>https://myapp.com/callback</example>
     [Required]
+    [JsonPropertyName("redirect_uri")]
     public string RedirectUri { get; set; } = string.Empty;
 
     /// <summary>
     /// An opaque value used for preventing CSRF attacks
     /// </summary>
     /// <example>abc123</example>
+    [JsonPropertyName("state")]
     public string State { get; set; } = string.Empty;
 
     /// <summary>
     /// Optional tenant identifier. If provided, tenant field will be pre-filled and hidden on the login form
     /// </summary>
     /// <example>tenant1</example>
+    [JsonPropertyName("tenant")]
     public string? Tenant { get; set; }
 
     /// <summary>
     /// Optional scopes to request for the token. Scopes should be space-separated.
     /// </summary>
     /// <example>user_info profile email</example>
+    [JsonPropertyName("scope")]
     public string? Scopes { get; set; }
+
+    /// <summary>
+    /// PKCE code challenge - SHA-256 hash of the code verifier (recommended) or plain text verifier
+    /// </summary>
+    /// <example>E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM</example>
+    [JsonPropertyName("code_challenge")]
+    public string? CodeChallenge { get; set; }
+
+    /// <summary>
+    /// PKCE code challenge method - "S256" (recommended) or "plain"
+    /// </summary>
+    /// <example>S256</example>
+    [JsonPropertyName("code_challenge_method")]
+    public string? CodeChallengeMethod { get; set; }
 }
diff --git a/AuthServer/Models/TokenRequest.cs b/AuthServer/Models/TokenRequest.cs
new file mode 100644
index 0000000..a8d0798
--- /dev/null
+++ b/AuthServer/Models/TokenRequest.cs
@@ -0,0 +1,53 @@
+using System.ComponentModel.DataAnnotations;
+using System.Text.Json.Serialization;
+
+namespace AuthServer.Models;
+
+/// <summary>
+/// Represents a token request for OAuth 2.0 token endpoint
+/// </summary>
+public class TokenRequest
+{
+    /// <summary>
+    /// The grant type being requested
+    /// </summary>
+    [Required]
+    [JsonPropertyName("grant_type")]
+    public string GrantType { get; set; } = string.Empty;
+
+    /// <summary>
+    /// The authorization code received from the authorization endpoint
+    /// </summary>
+    [JsonPropertyName("code")]
+    public string? Code { get; set; }
+
+    /// <summary>
+    /// The redirect URI used in the authorization request
+    /// </summary>
+    [JsonPropertyName("redirect_uri")]
+    public string? RedirectUri { get; set; }
+
+    /// <summary>
+    /// The refresh token used to obtain a new access token
+    /// </summary>
+    [JsonPropertyName("refresh_token")]
+    public string? RefreshToken { get; set; }
+
+    /// <summary>
+    /// The client ID
+    /// </summary>
+    [JsonPropertyName("client_id")]
+    public string? ClientId { get; set; }
+
+    /// <summary>
+    /// The client secret
+    /// </summary>
+    [JsonPropertyName("client_secret")]
+    public string? ClientSecret { get; set; }
+
+    /// <summary>
+    /// The PKCE code verifier
+    /// </summary>
+    [JsonPropertyName("code_verifier")]
+    public string? CodeVerifier { get; set; }
+}
diff --git a/AuthServer/Pages/Auth/Login.cshtml b/AuthServer/Pages/Auth/Login.cshtml
index 0bad1ce..2836aab 100644
--- a/AuthServer/Pages/Auth/Login.cshtml
+++ b/AuthServer/Pages/Auth/Login.cshtml
@@ -2,6 +2,10 @@
 @model AuthServer.Pages.Auth.LoginModel
 @{
     ViewData["Title"] = "Login";
+
+    var clientId = HttpContext.Session.GetString("ClientId") ?? "default-client";
+    var scopes = HttpContext.Session.GetString("Scopes");
+    var isOAuthRequest = !string.IsNullOrEmpty(HttpContext.Session.GetString("RedirectUri"));
 }
 
 <!DOCTYPE html>
@@ -23,6 +27,8 @@
             --button-text-color: white;
             --shadow-color: rgba(0, 0, 0, 0.1);
             --error-color: #f44336;
+            --info-bg-color: #e3f2fd;
+            --info-text-color: #0d47a1;
         }
 
         @@media (prefers-color-scheme: dark) {
@@ -37,6 +43,8 @@
                 --button-text-color: #ffffff;
                 --shadow-color: rgba(0, 0, 0, 0.3);
                 --error-color: #f44336;
+                --info-bg-color: #1a237e;
+                --info-text-color: #bbdefb;
             }
         }
 
@@ -104,7 +112,6 @@
             border-radius: 4px;
             font-size: 1rem;
             cursor: pointer;
-            margin-top: 1rem;
             transition: background-color 0.3s ease;
         }
 
@@ -112,24 +119,42 @@
             background-color: var(--button-hover-bg-color);
         }
 
-        button:disabled {
-            background-color: #cccccc;
-            cursor: not-allowed;
-        }
-
-        .hidden {
-            display: none;
-        }
-
         .error-message {
             color: var(--error-color);
-            margin-top: 10px;
+            margin-bottom: 1rem;
             text-align: center;
+        }
+
+        .oauth-info {
+            background-color: var(--info-bg-color);
+            color: var(--info-text-color);
+            padding: 1rem;
+            border-radius: 4px;
+            margin-bottom: 1.5rem;
             font-size: 0.9rem;
         }
 
-        .text-danger {
-            color: var(--error-color);
+        .oauth-info h3 {
+            margin-top: 0;
+            margin-bottom: 0.5rem;
+        }
+
+        .oauth-info p {
+            margin: 0.5rem 0;
+        }
+
+        .scope-list {
+            display: flex;
+            flex-wrap: wrap;
+            gap: 0.5rem;
+            margin-top: 0.5rem;
+        }
+
+        .scope-item {
+            background-color: rgba(255, 255, 255, 0.2);
+            padding: 0.25rem 0.5rem;
+            border-radius: 4px;
+            font-size: 0.8rem;
         }
     </style>
 </head>
@@ -143,38 +168,56 @@
 
     <div class="login-container">
         <h1>Login</h1>
+
+        @if (isOAuthRequest)
+        {
+            <div class="oauth-info">
+                <h3>Authorization Request</h3>
+                <p><strong>Application:</strong> @clientId</p>
+
+                @if (!string.IsNullOrEmpty(scopes))
+                {
+                    <p><strong>Requested Permissions:</strong></p>
+                    <div class="scope-list">
+                        @foreach (var scope in scopes.Split(' ', StringSplitOptions.RemoveEmptyEntries))
+                        {
+                            <span class="scope-item">@scope</span>
+                        }
+                    </div>
+                }
+            </div>
+        }
+
+        @if (!string.IsNullOrEmpty(Model.ValidationError))
+        {
+            <div class="error-message">@Model.ValidationError</div>
+        }
+
         <form method="post">
             <div class="form-group">
-                <label for="username">Username</label>
-                <input type="text" id="username" name="Username" required>
-                <span asp-validation-for="Password" class="text-danger"></span>
+                <label for="Username">Username</label>
+                <input type="text" id="Username" name="Username" value="@Model.Username" required>
             </div>
+
             <div class="form-group">
-                <label for="password">Password</label>
-                <input type="password" id="password" name="Password" required>
-                <span asp-validation-for="Password" class="text-danger"></span>
+                <label for="Password">Password</label>
+                <input type="password" id="Password" name="Password" required>
             </div>
 
-            @if (string.IsNullOrEmpty(Model.Tenant))
+            @if (!string.IsNullOrEmpty(Model.Tenant))
             {
-                <div class="form-group" id="tenant-group">
-                    <label for="tenant">Tenant</label>
-                    <input type="text" id="tenant" name="Tenant" required value="tenant1">
-                    <span asp-validation-for="Tenant" class="text-danger"></span>
-                </div>
+                <input type="hidden" name="Tenant" value="@Model.Tenant">
             }
             else
             {
-                <input type="hidden" id="tenant" name="Tenant" value="@Model.Tenant">
+                <div class="form-group">
+                    <label for="Tenant">Tenant</label>
+                    <input type="text" id="Tenant" name="Tenant" value="@Model.Tenant" required>
+                </div>
             }
 
             @Html.AntiForgeryToken()
 
-            @if (!string.IsNullOrEmpty(Model.ValidationError))
-            {
-                <div class="error-message">@Model.ValidationError</div>
-            }
-
             <button type="submit">Login</button>
         </form>
     </div>
diff --git a/AuthServer/Pages/Auth/Login.cshtml.cs b/AuthServer/Pages/Auth/Login.cshtml.cs
index 9d00513..6bfcc92 100644
--- a/AuthServer/Pages/Auth/Login.cshtml.cs
+++ b/AuthServer/Pages/Auth/Login.cshtml.cs
@@ -9,6 +9,7 @@ namespace AuthServer.Pages.Auth;
 public class LoginModel(
     IAuthenticationService authService,
     IRedirectUriValidator redirectUriValidator,
+    IAuthCodeRepository authCodeRepository,
     ILogger<LoginModel> logger
 ) : PageModel
 {
@@ -45,6 +46,9 @@ public class LoginModel(
         var state = HttpContext.Session.GetString("State");
         var redirectUri = HttpContext.Session.GetString("RedirectUri");
         var scopesValue = HttpContext.Session.GetString("Scopes");
+        _ = HttpContext.Session.GetString("ClientId") ?? "default-client";
+        var codeChallenge = HttpContext.Session.GetString("CodeChallenge");
+        var codeChallengeMethod = HttpContext.Session.GetString("CodeChallengeMethod");
 
         if (string.IsNullOrEmpty(redirectUri))
         {
@@ -70,20 +74,25 @@ public class LoginModel(
             return Page();
         }
 
-        var uriBuilder = new UriBuilder(redirectUri);
-        var query = HttpUtility.ParseQueryString(uriBuilder.Query);
-
         // Parse scopes from session, default to user_info if not provided
         var scopesList = string.IsNullOrEmpty(scopesValue)
             ? ["user_info"]
             : scopesValue.Split(' ', StringSplitOptions.RemoveEmptyEntries).ToList();
 
-        // Generate both access token and refresh token with the requested scopes
-        var (accessToken, refreshToken) = authService.GenerateTokenWithRefresh(user, scopesList);
+        // Generate an authorization code
+        var authCode = authCodeRepository.Create(
+            user.Id,
+            redirectUri,
+            scopesList,
+            codeChallenge,
+            codeChallengeMethod
+        );
+
+        var uriBuilder = new UriBuilder(redirectUri);
+        var query = HttpUtility.ParseQueryString(uriBuilder.Query);
 
-        // Add both tokens to the redirect URL
-        query["token"] = accessToken;
-        query["refreshToken"] = refreshToken.Token;
+        // Add the authorization code to the redirect URL
+        query["code"] = authCode;
 
         if (!string.IsNullOrEmpty(state))
         {
@@ -92,10 +101,20 @@ public class LoginModel(
 
         uriBuilder.Query = query.ToString();
 
+        // Clear session data
         HttpContext.Session.Remove("RedirectUri");
         HttpContext.Session.Remove("State");
         HttpContext.Session.Remove("Tenant");
         HttpContext.Session.Remove("Scopes");
+        HttpContext.Session.Remove("ClientId");
+        HttpContext.Session.Remove("CodeChallenge");
+        HttpContext.Session.Remove("CodeChallengeMethod");
+
+        logger.LogInformation(
+            "User {Username} authenticated successfully. Redirecting to {RedirectUri} with authorization code",
+            user.Username,
+            redirectUri
+        );
 
         return Redirect(uriBuilder.ToString());
     }
diff --git a/AuthServer/Program.cs b/AuthServer/Program.cs
index 9a742d7..1677381 100644
--- a/AuthServer/Program.cs
+++ b/AuthServer/Program.cs
@@ -2,10 +2,14 @@
 
 using AuthServer.Contracts;
 using AuthServer.Extensions;
+using AuthServer.Middleware;
 using AuthServer.Models;
-using AuthServer.Services;
+using AuthServer.Services.Authentication;
+using AuthServer.Services.Client;
+using AuthServer.Services.Token;
 using Microsoft.AspNetCore.Authentication.JwtBearer;
 using Microsoft.AspNetCore.Diagnostics.HealthChecks;
+using Microsoft.AspNetCore.Http.Features;
 using Microsoft.Extensions.Diagnostics.HealthChecks;
 using Microsoft.IdentityModel.Tokens;
 using Serilog;
@@ -42,7 +46,33 @@ builder.Services.AddCors(options =>
 });
 
 // Add services to the container
-builder.Services.AddControllers();
+builder
+    .Services.AddControllers()
+    .AddJsonOptions(options =>
+    {
+        // Configure JSON serialization to handle both snake_case and PascalCase
+        options.JsonSerializerOptions.PropertyNamingPolicy = null; // Use property names as-is
+        options.JsonSerializerOptions.PropertyNameCaseInsensitive = true; // Case-insensitive property matching
+    })
+    .ConfigureApiBehaviorOptions(options =>
+    {
+        // Configure form binding to handle snake_case parameter names
+        options.SuppressModelStateInvalidFilter = true;
+    })
+    .AddMvcOptions(options =>
+    {
+        // Configure form options to handle form data
+        options.EnableEndpointRouting = true;
+    });
+
+// Configure form options
+builder.Services.Configure<FormOptions>(options =>
+{
+    options.ValueLengthLimit = int.MaxValue;
+    options.MultipartBodyLengthLimit = int.MaxValue;
+    options.MultipartHeadersLengthLimit = int.MaxValue;
+});
+
 builder.Services.AddRazorPages();
 builder.Services.AddEndpointsApiExplorer();
 builder.Services.AddSwagger();
@@ -70,10 +100,13 @@ builder
     });
 
 builder
-    .Services.AddScoped<IAuthenticationService, AuthenticationService>()
+    .Services.AddSingleton<IUserRepository, InMemoryUserRepository>()
+    .AddScoped<IAuthenticationService, AuthenticationService>()
     .AddSingleton<IKeyManagementService, KeyManagementService>()
     .AddSingleton<IRedirectUriValidator, RedirectUriValidator>()
     .AddSingleton<IRefreshTokenService, RefreshTokenService>()
+    .AddSingleton<IAuthCodeRepository, InMemoryAuthCodeRepository>()
+    .AddSingleton<IOAuthClientRepository, InMemoryOAuthClientRepository>()
     .RegisterConfiguration<TokenConfiguration>("Token", ServiceLifetime.Singleton)
     .AddDistributedMemoryCache()
     .AddSession(options =>
@@ -103,6 +136,7 @@ app.UseSwaggerUI();
 if (!app.Environment.IsDevelopment())
 {
     app.UseHsts();
+    app.UseHttpsRedirection();
     app.Use(
         async (context, next) =>
         {
@@ -126,11 +160,11 @@ if (!app.Environment.IsDevelopment())
 }
 
 app.UseCors("AllowSpaOrigin");
-app.UseHttpsRedirection();
 app.UseSession();
 app.ConfigureJwtValidation();
 app.UseAuthentication();
 app.UseAuthorization();
+app.UseMiddleware<ExceptionHandlingMiddleware>();
 app.MapControllers();
 app.MapRazorPages();
 
diff --git a/AuthServer/Services/AuthenticationService.cs b/AuthServer/Services/Authentication/AuthenticationService.cs
similarity index 67%
rename from AuthServer/Services/AuthenticationService.cs
rename to AuthServer/Services/Authentication/AuthenticationService.cs
index ad79cb4..12aa482 100644
--- a/AuthServer/Services/AuthenticationService.cs
+++ b/AuthServer/Services/Authentication/AuthenticationService.cs
@@ -4,43 +4,18 @@ using AuthServer.Contracts;
 using AuthServer.Models;
 using Microsoft.IdentityModel.Tokens;
 
-namespace AuthServer.Services;
+namespace AuthServer.Services.Authentication;
 
 public class AuthenticationService(
     IKeyManagementService keyManagementService,
     TokenConfiguration tokenConfiguration,
-    IRefreshTokenService refreshTokenService
+    IRefreshTokenService refreshTokenService,
+    IUserRepository userRepository
 ) : IAuthenticationService
 {
-    private readonly List<User> _users =
-    [
-        new User
-        {
-            Id = "1",
-            Username = "user1",
-            PasswordHash = BCrypt.Net.BCrypt.HashPassword("password1"),
-            Tenant = "tenant1",
-            Roles = ["User"],
-        },
-        new User
-        {
-            Id = "2",
-            Username = "admin",
-            PasswordHash = BCrypt.Net.BCrypt.HashPassword("adminpass"),
-            Tenant = "tenant1",
-            Roles = ["User", "Admin"],
-        },
-    ];
-
     public async Task<User?> AttemptLogin(string username, string password, string tenant)
     {
-        var user = await Task.FromResult(
-            _users.FirstOrDefault(u => u.Username == username && u.Tenant == tenant)
-        );
-
-        return user is not null && BCrypt.Net.BCrypt.Verify(password, user.PasswordHash)
-            ? user
-            : null;
+        return await userRepository.ValidateCredentials(username, password, tenant);
     }
 
     public string GenerateToken(User user, List<string> scopes)
@@ -101,14 +76,14 @@ public class AuthenticationService(
             return (null, null);
         }
 
-        var user = new User
+        // Get the complete user data from the repository
+        var user = await userRepository.GetUserById(rotatedToken.UserId);
+
+        if (user == null)
         {
-            Id = rotatedToken.UserId,
-            Username = rotatedToken.Username,
-            Tenant = rotatedToken.Tenant,
-            // Roles are not stored in refresh token for security reasons
-            Roles = [],
-        };
+            // This should not happen in normal operation
+            return (null, null);
+        }
 
         var accessToken = GenerateToken(user, rotatedToken.Scopes);
 
diff --git a/AuthServer/Services/Authentication/InMemoryUserRepository.cs b/AuthServer/Services/Authentication/InMemoryUserRepository.cs
new file mode 100644
index 0000000..62341db
--- /dev/null
+++ b/AuthServer/Services/Authentication/InMemoryUserRepository.cs
@@ -0,0 +1,131 @@
+using System.Collections.Concurrent;
+using AuthServer.Contracts;
+using AuthServer.Models;
+
+namespace AuthServer.Services.Authentication;
+
+/// <summary>
+/// In-memory implementation of the user repository
+/// </summary>
+public class InMemoryUserRepository(ILogger<InMemoryUserRepository> logger) : IUserRepository
+{
+    private readonly ConcurrentDictionary<string, User> _usersById = new()
+    {
+        ["user1"] = new User
+        {
+            Id = "user1",
+            Username = "user1",
+            Tenant = "tenant1",
+            PasswordHash = BCrypt.Net.BCrypt.HashPassword("password1"),
+            Roles = ["user"],
+        },
+        ["admin1"] = new User
+        {
+            Id = "admin1",
+            Username = "admin",
+            Tenant = "tenant1",
+            PasswordHash = BCrypt.Net.BCrypt.HashPassword("adminpassword"),
+            Roles = ["user", "admin"],
+        },
+        ["user2"] = new User
+        {
+            Id = "user2",
+            Username = "user2",
+            Tenant = "tenant2",
+            PasswordHash = BCrypt.Net.BCrypt.HashPassword("password2"),
+            Roles = ["user"],
+        },
+    };
+    private readonly ConcurrentDictionary<string, string> _userKeysByUsername = new()
+    {
+        ["user1:tenant1"] = "user1",
+        ["admin:tenant1"] = "admin1",
+        ["user2:tenant2"] = "user2",
+    };
+
+    /// <summary>
+    /// Validates user credentials
+    /// </summary>
+    public Task<User?> ValidateCredentials(string username, string password, string tenant)
+    {
+        // Construct the lookup key
+        var lookupKey = GetLookupKey(username, tenant);
+
+        // Try to find the user
+        if (
+            !_userKeysByUsername.TryGetValue(lookupKey, out var userId)
+            || !_usersById.TryGetValue(userId, out var user)
+        )
+        {
+            logger.LogWarning("User not found: {Username} in tenant {Tenant}", username, tenant);
+            return Task.FromResult<User?>(null);
+        }
+
+        // Validate password - in production this would use BCrypt or similar
+        if (!ValidatePassword(password, user.PasswordHash))
+        {
+            logger.LogWarning(
+                "Invalid password for user: {Username} in tenant {Tenant}",
+                username,
+                tenant
+            );
+            return Task.FromResult<User?>(null);
+        }
+
+        logger.LogInformation(
+            "User authenticated: {Username} in tenant {Tenant}",
+            username,
+            tenant
+        );
+        return Task.FromResult<User?>(user);
+    }
+
+    /// <summary>
+    /// Gets a user by ID
+    /// </summary>
+    public Task<User?> GetUserById(string userId)
+    {
+        if (_usersById.TryGetValue(userId, out var user))
+        {
+            return Task.FromResult<User?>(user);
+        }
+
+        logger.LogWarning("User ID not found: {UserId}", userId);
+        return Task.FromResult<User?>(null);
+    }
+
+    /// <summary>
+    /// Gets a user by username in a tenant
+    /// </summary>
+    public Task<User?> GetUserByUsername(string username, string tenant)
+    {
+        var lookupKey = GetLookupKey(username, tenant);
+
+        if (
+            _userKeysByUsername.TryGetValue(lookupKey, out var userId)
+            && _usersById.TryGetValue(userId, out var user)
+        )
+        {
+            return Task.FromResult<User?>(user);
+        }
+
+        logger.LogWarning("User not found: {Username} in tenant {Tenant}", username, tenant);
+        return Task.FromResult<User?>(null);
+    }
+
+    /// <summary>
+    /// Creates a lookup key for username/tenant pairs
+    /// </summary>
+    private static string GetLookupKey(string username, string tenant)
+    {
+        return $"{username.ToLowerInvariant()}:{tenant.ToLowerInvariant()}";
+    }
+
+    /// <summary>
+    /// Validates a password against a hash
+    /// </summary>
+    private static bool ValidatePassword(string password, string hash)
+    {
+        return BCrypt.Net.BCrypt.Verify(password, hash);
+    }
+}
diff --git a/AuthServer/Services/Client/AuthCodeRepository.cs b/AuthServer/Services/Client/AuthCodeRepository.cs
new file mode 100644
index 0000000..5daf3df
--- /dev/null
+++ b/AuthServer/Services/Client/AuthCodeRepository.cs
@@ -0,0 +1,113 @@
+using System.Collections.Concurrent;
+using AuthServer.Contracts;
+
+namespace AuthServer.Services.Client;
+
+/// <summary>
+/// In-memory implementation of the authorization code repository
+/// </summary>
+public class InMemoryAuthCodeRepository(ILogger<InMemoryAuthCodeRepository> logger)
+    : IAuthCodeRepository
+{
+    private readonly ConcurrentDictionary<string, AuthCodeData> _authCodes = new();
+
+    /// <summary>
+    /// Creates a new authorization code and stores it with the provided data
+    /// </summary>
+    public string Create(
+        string userId,
+        string redirectUri,
+        IEnumerable<string> scopes,
+        string? codeChallenge = null,
+        string? codeChallengeMethod = null
+    )
+    {
+        // Generate a random auth code
+        var code = Convert
+            .ToBase64String(Guid.NewGuid().ToByteArray())
+            .Replace("/", "_")
+            .Replace("+", "-")
+            .Replace("=", "")[..20];
+
+        var authCodeData = new AuthCodeData
+        {
+            UserId = userId,
+            RedirectUri = redirectUri,
+            Scopes = scopes.ToList(),
+            CodeChallenge = codeChallenge,
+            CodeChallengeMethod = codeChallengeMethod,
+            CreatedAt = DateTime.UtcNow,
+            ExpiresAt = DateTime.UtcNow.AddMinutes(10), // Authorization codes valid for 10 minutes
+        };
+
+        _authCodes[code] = authCodeData;
+
+        // Log the full details of the created code
+        logger.LogInformation(
+            "Authorization code created: code={Code}, userId={UserId}, redirectUri={RedirectUri}, expiresAt={ExpiresAt}",
+            code,
+            userId,
+            redirectUri,
+            authCodeData.ExpiresAt
+        );
+
+        return code;
+    }
+
+    /// <summary>
+    /// Validates and consumes an authorization code, returning the associated data
+    /// </summary>
+    public Task<AuthCodeData?> Consume(string code, string redirectUri)
+    {
+        // Log the attempt to consume the code
+        logger.LogInformation(
+            "Attempting to consume authorization code: code={Code}, redirectUri={RedirectUri}",
+            code,
+            redirectUri
+        );
+
+        // Try to get and remove the auth code from the dictionary
+        if (!_authCodes.TryRemove(code, out var authCodeData))
+        {
+            logger.LogWarning(
+                "Authorization code not found: code={Code}, redirectUri={RedirectUri}",
+                code,
+                redirectUri
+            );
+            return Task.FromResult<AuthCodeData?>(null);
+        }
+
+        // Verify the code hasn't expired
+        if (authCodeData.ExpiresAt < DateTime.UtcNow)
+        {
+            logger.LogWarning(
+                "Authorization code expired: code={Code}, userId={UserId}, redirectUri={RedirectUri}, expiresAt={ExpiresAt}",
+                code,
+                authCodeData.UserId,
+                redirectUri,
+                authCodeData.ExpiresAt
+            );
+            return Task.FromResult<AuthCodeData?>(null);
+        }
+
+        // Verify the redirect URI matches
+        if (authCodeData.RedirectUri != redirectUri)
+        {
+            logger.LogWarning(
+                "Authorization code redirect URI mismatch: code={Code}, expected={ExpectedRedirectUri}, actual={ActualRedirectUri}",
+                code,
+                authCodeData.RedirectUri,
+                redirectUri
+            );
+            return Task.FromResult<AuthCodeData?>(null);
+        }
+
+        logger.LogInformation(
+            "Authorization code consumed successfully: code={Code}, userId={UserId}, redirectUri={RedirectUri}",
+            code,
+            authCodeData.UserId,
+            redirectUri
+        );
+        return Task.FromResult<AuthCodeData?>(authCodeData);
+    }
+}
diff --git a/AuthServer/Services/Client/OAuthClientRepository.cs b/AuthServer/Services/Client/OAuthClientRepository.cs
new file mode 100644
index 0000000..f5bed1f
--- /dev/null
+++ b/AuthServer/Services/Client/OAuthClientRepository.cs
@@ -0,0 +1,129 @@
+using System.Collections.Concurrent;
+using AuthServer.Contracts;
+using AuthServer.Models;
+
+namespace AuthServer.Services.Client;
+
+/// <summary>
+/// In-memory implementation of the OAuth client repository
+/// </summary>
+public class InMemoryOAuthClientRepository(ILogger<InMemoryOAuthClientRepository> logger)
+    : IOAuthClientRepository
+{
+    private readonly ConcurrentDictionary<string, OAuthClient> _clients = new()
+    {
+        ["weather-spa"] = new OAuthClient
+        {
+            ClientId = "weather-spa",
+            ClientName = "Weather SPA",
+            Description = "React Single Page Application for weather data",
+            RedirectUris = ["http://localhost:5173/callback", "http://127.0.0.1:5173/callback"],
+            AllowedScopes = ["openid", "profile", "email", "weather.read"],
+            IsPublicClient = true,
+        },
+        ["default-client"] = new OAuthClient
+        {
+            ClientId = "default-client",
+            ClientName = "Default Client",
+            Description = "Default client for backward compatibility",
+            RedirectUris = ["http://localhost:5173/callback", "http://127.0.0.1:5173/callback"],
+            AllowedScopes = ["openid", "profile", "email", "weather.read"], // Weather SPA
+            IsPublicClient = true,
+        },
+    };
+
+    /// <summary>
+    /// Gets a client by its ID
+    /// </summary>
+    public Task<OAuthClient?> GetClientByIdAsync(string clientId)
+    {
+        _ = _clients.TryGetValue(clientId, out var client);
+        return Task.FromResult(client);
+    }
+
+    /// <summary>
+    /// Creates a new client
+    /// </summary>
+    public Task<OAuthClient> CreateClientAsync(OAuthClient client)
+    {
+        if (_clients.TryAdd(client.ClientId, client))
+        {
+            logger.LogInformation("Created client: {ClientId}", client.ClientId);
+            return Task.FromResult(client);
+        }
+
+        logger.LogWarning("Failed to create client: {ClientId} - already exists", client.ClientId);
+        throw new InvalidOperationException($"Client with ID {client.ClientId} already exists");
+    }
+
+    /// <summary>
+    /// Updates an existing client
+    /// </summary>
+    public Task<bool> UpdateClientAsync(OAuthClient client)
+    {
+        var result = _clients.TryUpdate(
+            client.ClientId,
+            client,
+            _clients.GetOrAdd(client.ClientId, client)
+        );
+        logger.LogInformation("Updated client: {ClientId} - {Result}", client.ClientId, result);
+        return Task.FromResult(result);
+    }
+
+    /// <summary>
+    /// Deletes a client
+    /// </summary>
+    public Task<bool> DeleteClientAsync(string clientId)
+    {
+        var result = _clients.TryRemove(clientId, out _);
+        logger.LogInformation("Deleted client: {ClientId} - {Result}", clientId, result);
+        return Task.FromResult(result);
+    }
+
+    /// <summary>
+    /// Gets all clients
+    /// </summary>
+    public Task<List<OAuthClient>> GetAllClientsAsync()
+    {
+        return Task.FromResult(_clients.Values.ToList());
+    }
+
+    /// <summary>
+    /// Validates a redirect URI for a client
+    /// </summary>
+    public Task<bool> ValidateRedirectUriAsync(string clientId, string redirectUri)
+    {
+        if (!_clients.TryGetValue(clientId, out var client))
+        {
+            logger.LogWarning("Client not found: {ClientId}", clientId);
+
+            // For backward compatibility, allow any redirect URI if the client is not found
+            if (clientId == "default-client")
+            {
+                logger.LogInformation(
+                    "Using default client for redirect URI validation: {RedirectUri}",
+                    redirectUri
+                );
+                return Task.FromResult(true);
+            }
+
+            return Task.FromResult(false);
+        }
+
+        if (!client.IsActive)
+        {
+            logger.LogWarning("Client is inactive: {ClientId}", clientId);
+            return Task.FromResult(false);
+        }
+
+        var isValid = client.RedirectUris.Contains(redirectUri);
+        logger.LogInformation(
+            "Redirect URI validation for client {ClientId}: {RedirectUri} - {Result}",
+            clientId,
+            redirectUri,
+            isValid
+        );
+
+        return Task.FromResult(isValid);
+    }
+}
diff --git a/AuthServer/Services/RedirectUriValidator.cs b/AuthServer/Services/Client/RedirectUriValidator.cs
similarity index 98%
rename from AuthServer/Services/RedirectUriValidator.cs
rename to AuthServer/Services/Client/RedirectUriValidator.cs
index 96c87e6..719d4bd 100644
--- a/AuthServer/Services/RedirectUriValidator.cs
+++ b/AuthServer/Services/Client/RedirectUriValidator.cs
@@ -1,7 +1,7 @@
 using System.Text.RegularExpressions;
 using AuthServer.Contracts;
 
-namespace AuthServer.Services;
+namespace AuthServer.Services.Client;
 
 /// <summary>
 /// Service for validating redirect URIs to prevent open redirect vulnerabilities
diff --git a/AuthServer/Services/Log.cs b/AuthServer/Services/Infrastructure/Log.cs
similarity index 60%
rename from AuthServer/Services/Log.cs
rename to AuthServer/Services/Infrastructure/Log.cs
index a7e02fa..aaeb075 100644
--- a/AuthServer/Services/Log.cs
+++ b/AuthServer/Services/Infrastructure/Log.cs
@@ -1,4 +1,4 @@
-namespace AuthServer.Services;
+namespace AuthServer.Services.Infrastructure;
 
 public static class Log
 {
@@ -58,6 +58,41 @@ public static class Log
             "Redirect login failed for user {Username} in tenant {Tenant}: Invalid credentials"
         );
 
+    private static readonly Action<ILogger, string, string, Exception?> _authCodeCreated =
+        LoggerMessage.Define<string, string>(
+            LogLevel.Information,
+            new EventId(9, nameof(AuthCodeCreated)),
+            "Authorization code created for user ID {UserId} with redirect URI {RedirectUri}"
+        );
+
+    private static readonly Action<ILogger, string, string, Exception?> _authCodeConsumed =
+        LoggerMessage.Define<string, string>(
+            LogLevel.Information,
+            new EventId(10, nameof(AuthCodeConsumed)),
+            "Authorization code consumed for user ID {UserId} with redirect URI {RedirectUri}"
+        );
+
+    private static readonly Action<ILogger, string, Exception?> _authCodeInvalid =
+        LoggerMessage.Define<string>(
+            LogLevel.Warning,
+            new EventId(11, nameof(AuthCodeInvalid)),
+            "Invalid authorization code: {Code}"
+        );
+
+    private static readonly Action<ILogger, string, string, Exception?> _authCodeExpired =
+        LoggerMessage.Define<string, string>(
+            LogLevel.Warning,
+            new EventId(12, nameof(AuthCodeExpired)),
+            "Expired authorization code for user ID {UserId} with redirect URI {RedirectUri}"
+        );
+
+    private static readonly Action<ILogger, string, string, Exception?> _authCodeRedirectMismatch =
+        LoggerMessage.Define<string, string>(
+            LogLevel.Warning,
+            new EventId(13, nameof(AuthCodeRedirectMismatch)),
+            "Redirect URI mismatch for authorization code. Expected: {ExpectedUri}, Got: {ActualUri}"
+        );
+
     public static void LoginAttempt(ILogger logger, string username, string tenant)
     {
         _loginAttempt(logger, username, tenant, null);
@@ -102,4 +137,33 @@ public static class Log
     {
         _tokenRefreshed(logger, username, null);
     }
+
+    public static void AuthCodeCreated(ILogger logger, string userId, string redirectUri)
+    {
+        _authCodeCreated(logger, userId, redirectUri, null);
+    }
+
+    public static void AuthCodeConsumed(ILogger logger, string userId, string redirectUri)
+    {
+        _authCodeConsumed(logger, userId, redirectUri, null);
+    }
+
+    public static void AuthCodeInvalid(ILogger logger, string code)
+    {
+        _authCodeInvalid(logger, code, null);
+    }
+
+    public static void AuthCodeExpired(ILogger logger, string userId, string redirectUri)
+    {
+        _authCodeExpired(logger, userId, redirectUri, null);
+    }
+
+    public static void AuthCodeRedirectMismatch(
+        ILogger logger,
+        string expectedUri,
+        string actualUri
+    )
+    {
+        _authCodeRedirectMismatch(logger, expectedUri, actualUri, null);
+    }
 }
diff --git a/AuthServer/Services/KeyManagementHealthCheck.cs b/AuthServer/Services/Token/KeyManagementHealthCheck.cs
similarity index 97%
rename from AuthServer/Services/KeyManagementHealthCheck.cs
rename to AuthServer/Services/Token/KeyManagementHealthCheck.cs
index 3449589..1fe7c0e 100644
--- a/AuthServer/Services/KeyManagementHealthCheck.cs
+++ b/AuthServer/Services/Token/KeyManagementHealthCheck.cs
@@ -1,7 +1,7 @@
 using AuthServer.Contracts;
 using Microsoft.Extensions.Diagnostics.HealthChecks;
 
-namespace AuthServer.Services;
+namespace AuthServer.Services.Token;
 
 /// <summary>
 /// Health check that verifies the KeyManagementService is properly initialized
diff --git a/AuthServer/Services/KeyManagementService.cs b/AuthServer/Services/Token/KeyManagementService.cs
similarity index 98%
rename from AuthServer/Services/KeyManagementService.cs
rename to AuthServer/Services/Token/KeyManagementService.cs
index e3bd97f..458d211 100644
--- a/AuthServer/Services/KeyManagementService.cs
+++ b/AuthServer/Services/Token/KeyManagementService.cs
@@ -4,7 +4,7 @@ using AuthServer.Models;
 using Microsoft.IdentityModel.Tokens;
 using JWK = Microsoft.IdentityModel.Tokens.JsonWebKey;
 
-namespace AuthServer.Services;
+namespace AuthServer.Services.Token;
 
 /// <summary>
 /// Service for managing cryptographic keys.
diff --git a/AuthServer/Services/RefreshTokenCleanupService.cs b/AuthServer/Services/Token/RefreshTokenCleanupService.cs
similarity index 97%
rename from AuthServer/Services/RefreshTokenCleanupService.cs
rename to AuthServer/Services/Token/RefreshTokenCleanupService.cs
index 5055239..b898d22 100644
--- a/AuthServer/Services/RefreshTokenCleanupService.cs
+++ b/AuthServer/Services/Token/RefreshTokenCleanupService.cs
@@ -1,7 +1,7 @@
 using AuthServer.Contracts;
 using AuthServer.Models;
 
-namespace AuthServer.Services;
+namespace AuthServer.Services.Token;
 
 /// <summary>
 /// Background service that periodically cleans up expired refresh tokens
diff --git a/AuthServer/Services/RefreshTokenService.cs b/AuthServer/Services/Token/RefreshTokenService.cs
similarity index 97%
rename from AuthServer/Services/RefreshTokenService.cs
rename to AuthServer/Services/Token/RefreshTokenService.cs
index 1c0636d..62fbb99 100644
--- a/AuthServer/Services/RefreshTokenService.cs
+++ b/AuthServer/Services/Token/RefreshTokenService.cs
@@ -2,7 +2,7 @@ using System.Collections.Concurrent;
 using AuthServer.Contracts;
 using AuthServer.Models;
 
-namespace AuthServer.Services;
+namespace AuthServer.Services.Token;
 
 public class RefreshTokenService(TokenConfiguration tokenConfiguration) : IRefreshTokenService
 {
@@ -65,7 +65,7 @@ public class RefreshTokenService(TokenConfiguration tokenConfiguration) : IRefre
         return newRefreshToken;
     }
 
-    public async Task<bool> RevokeRefreshToken(string token)
+    public async Task<bool> Revoke(string token)
     {
         var existingToken = await GetByToken(token);
 
diff --git a/CLAUDE.md b/CLAUDE.md
new file mode 100644
index 0000000..fb0641c
--- /dev/null
+++ b/CLAUDE.md
@@ -0,0 +1,39 @@
+# AuthTest Project Guidelines
+
+## Build, Lint, and Test Commands
+- **Auth Server**: `dotnet build/run/test/watch AuthServer`
+- **Weather API**: `dotnet build/run/test/watch WeatherApi`
+- **Weather SPA**: 
+  - Development: `npm run dev` (WeatherSpa)
+  - Tests/Linting: `npm run lint:fix format typecheck validate` (WeatherSpa)
+- **Single Test (.NET)**: `dotnet test --filter "FullyQualifiedName=Namespace.TestClass.TestMethod"`
+- **Formatting (.NET)**: `dotnet csharpier AuthServer` or `dotnet csharpier WeatherApi` (to format a specific project)
+
+## Code Style Guidelines
+- **C# (.NET)**: 
+  - File-scoped namespaces, 4-space indent, PascalCase types/public members
+  - Private fields: camelCase with `_` prefix
+  - Imports outside namespaces, use async/await consistently
+  - Use dependency injection with primary constructors
+  - XML documentation on public APIs and interfaces
+  - Always use ProblemDetails for API error responses with appropriate status codes
+  - OAuth endpoints should include standard OAuth error codes in ProblemDetails extensions
+  - Use CSharpier for code formatting (`dotnet csharpier <project>` before committing)
+
+- **TypeScript/React**: 
+  - Function components with explicit prop interfaces
+  - PascalCase components, camelCase functions, kebab-case files/CSS
+  - Group imports by: React, components, hooks, services, types, CSS
+  - Component-scoped CSS with semantic class names
+  - Use existing design system components before creating new ones
+
+## Security
+- Never log/expose JWT tokens, secrets, or credentials
+- JWT with refresh token rotation in auth flows
+- Validate all input data, especially in authentication flows
+- Handle errors appropriately with user feedback
+- Redirect authentication should use authorization codes, not direct tokens
+
+Always run lint/validate/format before committing changes:
+- .NET: `dotnet csharpier <project>` (formats C# code)
+- SPA: `npm run validate` (runs typecheck, lint, format:check)
\ No newline at end of file
diff --git a/WeatherApi/Program.cs b/WeatherApi/Program.cs
index 8ef071d..45f6175 100644
--- a/WeatherApi/Program.cs
+++ b/WeatherApi/Program.cs
@@ -66,8 +66,8 @@ builder
 // Add authorization
 builder
     .Services.AddAuthorizationBuilder()
-    .AddPolicy("ReadAccess", policy => policy.RequireClaim("scope", "read"))
-    .AddPolicy("WriteAccess", policy => policy.RequireClaim("scope", "write"));
+    .AddPolicy("ReadAccess", policy => policy.RequireClaim("scope", "weather.read"))
+    .AddPolicy("WriteAccess", policy => policy.RequireClaim("scope", "weather.write"));
 
 // Configure Swagger with JWT support
 builder.Services.AddEndpointsApiExplorer();
diff --git a/WeatherSpa/CLAUDE.md b/WeatherSpa/CLAUDE.md
new file mode 100644
index 0000000..07f4269
--- /dev/null
+++ b/WeatherSpa/CLAUDE.md
@@ -0,0 +1,21 @@
+# WeatherSpa Development Guidelines
+
+## Commands
+- **Dev server**: `npm run dev`
+- **Build**: `npm run build`
+- **Preview build**: `npm run preview`
+- **Lint**: `npm run lint` (check), `npm run lint:fix` (auto-fix)
+- **Format**: `npm run format` (fix), `npm run format:check` (check)
+- **Typecheck**: `npm run typecheck`, `npm run typecheck:watch` (watch mode)
+- **Validate**: `npm run validate` (runs typecheck, lint, format:check)
+
+## Code Style
+- **Components**: Function components with explicit prop interfaces
+- **Naming**: PascalCase for components, camelCase for functions, kebab-case for files/CSS
+- **Typing**: Strong TypeScript typing, explicit interfaces for props/state
+- **Imports**: Group by: React, components, hooks/contexts, services, types, CSS (last)
+- **CSS**: Component-scoped CSS files with kebab-case classnames
+- **Error handling**: Try/catch for API calls, explicit error states with UI feedback
+- **State management**: Context API for auth, local state with proper typing
+- **Architecture**: Separate concerns (pages, components, services, contexts)
+- **Design system**: Use existing components before creating new ones
\ No newline at end of file
diff --git a/WeatherSpa/src/app.css b/WeatherSpa/src/app.css
index 5d55c27..6e57ed9 100644
--- a/WeatherSpa/src/app.css
+++ b/WeatherSpa/src/app.css
@@ -1,35 +1,50 @@
 :root {
   /* Primary brand color - OKLCH */
-  --primary: oklch(0.623 0.214 259.815); /* Blue */
+  --primary: oklch(0.623 0.214 259.815);
+  /* Blue */
   --primary-light: oklch(0.67 0.214 259.815);
-  --primary-rgb: 61, 109, 245; /* RGB for use in rgba() */
+  --primary-rgb: 61, 109, 245;
+  /* RGB for use in rgba() */
 
   /* Neutral palette - OKLCH */
-  --gray-50: oklch(0.98 0.005 255); /* #f9fafb */
-  --gray-100: oklch(0.96 0.005 255); /* #f3f4f6 */
-  --gray-200: oklch(0.92 0.005 255); /* #e5e7eb */
-  --gray-400: oklch(0.75 0.005 255); /* #9ca3af */
-  --gray-600: oklch(0.55 0.005 255); /* #4b5563 */
-  --gray-700: oklch(0.45 0.005 255); /* #374151 */
-  --gray-800: oklch(0.35 0.005 255); /* #1f2937 */
-  --gray-900: oklch(0.25 0.005 255); /* #111827 */
+  --gray-50: oklch(0.98 0.005 255);
+  /* #f9fafb */
+  --gray-100: oklch(0.96 0.005 255);
+  /* #f3f4f6 */
+  --gray-200: oklch(0.92 0.005 255);
+  /* #e5e7eb */
+  --gray-400: oklch(0.75 0.005 255);
+  /* #9ca3af */
+  --gray-600: oklch(0.55 0.005 255);
+  /* #4b5563 */
+  --gray-700: oklch(0.45 0.005 255);
+  /* #374151 */
+  --gray-800: oklch(0.35 0.005 255);
+  /* #1f2937 */
+  --gray-900: oklch(0.25 0.005 255);
+  /* #111827 */
 
   /* Semantic colors - OKLCH */
-  --success: oklch(0.655 0.157 159); /* #10b981 */
-  --success-light: oklch(0.9 0.07 159); /* #d1fae5 */
-  --error: oklch(0.65 0.26 27); /* #ef4444 */
-  --error-light: oklch(0.9 0.07 27); /* #fee2e2 */
-  --warning: oklch(0.7 0.18 75); /* #f59e0b */
-  --warning-light: oklch(0.95 0.05 75); /* #fef3c7 */
-  --info: oklch(0.65 0.18 230); /* #0284c7 */
-  --info-light: oklch(0.95 0.03 230); /* #e0f2fe */
+  --success: oklch(0.655 0.157 159);
+  /* #10b981 */
+  --success-light: oklch(0.9 0.07 159);
+  /* #d1fae5 */
+  --error: oklch(0.65 0.26 27);
+  /* #ef4444 */
+  --error-light: oklch(0.9 0.07 27);
+  /* #fee2e2 */
+  --warning: oklch(0.7 0.18 75);
+  /* #f59e0b */
+  --warning-light: oklch(0.95 0.05 75);
+  /* #fef3c7 */
+  --info: oklch(0.65 0.18 230);
+  /* #0284c7 */
+  --info-light: oklch(0.95 0.03 230);
+  /* #e0f2fe */
 
   /* Functional assignments */
   --background: var(--gray-50);
-  --background-rgb: 249, 250, 251; /* For rgba usage */
-  --surface: oklch(1 0 0); /* Pure white */
-  --surface-rgb: 255, 255, 255; /* For rgba usage */
-  --surface-hover: var(--gray-100);
+  --background-rgb: 249, 250, 251;
 
   --text-primary: var(--gray-800);
   --text-secondary: var(--gray-600);
@@ -130,15 +145,13 @@ p {
   :root {
     /* Keep primary the same for consistency across modes */
     --primary: oklch(0.623 0.214 259.815);
-    --primary-light: oklch(0.7 0.214 259.815); /* Brighter for dark mode */
+    --primary-light: oklch(0.7 0.214 259.815);
+    /* Brighter for dark mode */
     --primary-rgb: 61, 109, 245;
 
     /* Functional reassignments for dark mode */
     --background: var(--gray-900);
     --background-rgb: 17, 24, 39;
-    --surface: var(--gray-800);
-    --surface-rgb: 31, 41, 55;
-    --surface-hover: var(--gray-700);
 
     --text-primary: var(--gray-50);
     --text-secondary: var(--gray-200);
@@ -148,12 +161,16 @@ p {
     --border-light: var(--gray-800);
 
     /* Semi-transparent backgrounds for dark mode */
-    --success-bg: oklch(0.655 0.157 159 / 0.2); /* Success with opacity */
-    --error-bg: oklch(0.65 0.26 27 / 0.2); /* Error with opacity */
-    --warning-bg: oklch(0.7 0.18 75 / 0.2); /* Warning with opacity */
-    --info-bg: oklch(0.65 0.18 230 / 0.2); /* Info with opacity */
+    --success-bg: oklch(0.655 0.157 159 / 0.2);
+    /* Success with opacity */
+    --error-bg: oklch(0.65 0.26 27 / 0.2);
+    /* Error with opacity */
+    --warning-bg: oklch(0.7 0.18 75 / 0.2);
+    /* Warning with opacity */
+    --info-bg: oklch(0.65 0.18 230 / 0.2);
+    /* Info with opacity */
 
     --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.1);
     --shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
   }
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/card.css b/WeatherSpa/src/components/card.css
index f4d13cf..98239b2 100644
--- a/WeatherSpa/src/components/card.css
+++ b/WeatherSpa/src/components/card.css
@@ -1,6 +1,6 @@
 /* Card component base styles */
 .ds-card {
-  background-color: var(--surface);
+  background-color: var(--color-surface);
   border-radius: 8px;
   padding: 1.5rem;
   box-shadow: var(--shadow-sm);
@@ -40,4 +40,4 @@
   line-height: 1.5;
 }
 
-/* Dark mode adjustments are handled through CSS variables */
+/* Dark mode adjustments are handled through CSS variables */
\ No newline at end of file
diff --git a/WeatherSpa/src/components/checkbox-group.css b/WeatherSpa/src/components/checkbox-group.css
index 30f6574..febd58d 100644
--- a/WeatherSpa/src/components/checkbox-group.css
+++ b/WeatherSpa/src/components/checkbox-group.css
@@ -1,3 +1,13 @@
+.ds-checkbox-group {
+  display: flex;
+  flex-direction: column;
+  gap: 0.5rem;
+  background-color: var(--color-surface);
+  padding: 1rem;
+  border-radius: 4px;
+  border: 1px solid var(--color-border);
+}
+
 .checkbox-group {
   display: flex;
   flex-direction: column;
@@ -32,8 +42,8 @@
   display: flex;
   align-items: flex-start;
   padding: 8px;
-  background-color: var(--surface);
-  border: 1px solid var(--border);
+  background-color: var(--color-surface);
+  border: 1px solid var(--color-border);
   border-radius: 6px;
   transition:
     background-color 0.2s,
@@ -87,4 +97,4 @@
   .checkbox-group-grid.three-columns {
     grid-template-columns: repeat(3, 1fr);
   }
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/checkbox.css b/WeatherSpa/src/components/checkbox.css
new file mode 100644
index 0000000..8b0389e
--- /dev/null
+++ b/WeatherSpa/src/components/checkbox.css
@@ -0,0 +1,35 @@
+.checkbox-container {
+  margin: 1rem 0;
+}
+
+.checkbox-wrapper {
+  display: flex;
+  align-items: center;
+  gap: 0.5rem;
+}
+
+.checkbox-input {
+  width: 1.25rem;
+  height: 1.25rem;
+  border: 2px solid var(--color-border);
+  border-radius: 4px;
+  cursor: pointer;
+  transition: all 0.2s ease;
+}
+
+.checkbox-input:checked {
+  background-color: var(--color-primary);
+  border-color: var(--color-primary);
+}
+
+.checkbox-label {
+  font-size: 1rem;
+  color: var(--color-text);
+  cursor: pointer;
+}
+
+.checkbox-helper {
+  margin-top: 0.25rem;
+  font-size: 0.875rem;
+  color: var(--color-text-secondary);
+}
diff --git a/WeatherSpa/src/components/checkbox.tsx b/WeatherSpa/src/components/checkbox.tsx
new file mode 100644
index 0000000..1bac04b
--- /dev/null
+++ b/WeatherSpa/src/components/checkbox.tsx
@@ -0,0 +1,34 @@
+import { ChangeEvent } from 'react';
+import './checkbox.css';
+
+interface CheckboxProps {
+  id: string;
+  label: string;
+  checked: boolean;
+  onChange: (checked: boolean) => void;
+  helper?: string;
+}
+
+export function Checkbox({ id, label, checked, onChange, helper }: CheckboxProps) {
+  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
+    onChange(e.target.checked);
+  };
+
+  return (
+    <div className="checkbox-container">
+      <div className="checkbox-wrapper">
+        <input
+          type="checkbox"
+          id={id}
+          checked={checked}
+          onChange={handleChange}
+          className="checkbox-input"
+        />
+        <label htmlFor={id} className="checkbox-label">
+          {label}
+        </label>
+      </div>
+      {helper && <p className="checkbox-helper">{helper}</p>}
+    </div>
+  );
+}
diff --git a/WeatherSpa/src/components/design-system.ts b/WeatherSpa/src/components/design-system.ts
index e77d601..af7b3cb 100644
--- a/WeatherSpa/src/components/design-system.ts
+++ b/WeatherSpa/src/components/design-system.ts
@@ -1,34 +1,35 @@
 // Design System Components
 export * from './button';
 export * from './card';
-export * from './input';
-export * from './message';
+export * from './card-link';
+export * from './checkbox';
+export * from './checkbox-group';
 export * from './container';
-export * from './typography';
+export * from './divider';
 export * from './flex';
+export * from './form-group';
 export * from './grid';
 export * from './hero';
+export * from './input';
+export * from './login-layout';
+export * from './message';
 export * from './spinner';
+export * from './typography';
 export * from './user-info-banner';
-export * from './form-group';
-export * from './divider';
-export * from './checkbox-group';
-export * from './login-layout';
-export * from './card-link';
 
 // CSS Utilities (no exports, just imports to ensure they're available)
 import './a11y.css';
-import './spacing.css';
-import './typography.css';
-import './layout.css';
+import './card-link.css';
+import './checkbox-group.css';
+import './divider.css';
+import './form-group.css';
 import './hero.css';
+import './layout.css';
+import './login-layout.css';
+import './spacing.css';
 import './spinner.css';
+import './typography.css';
 import './user-info-banner.css';
-import './form-group.css';
-import './divider.css';
-import './checkbox-group.css';
-import './login-layout.css';
-import './card-link.css';
 
 // Export types
 export type {
@@ -40,31 +41,31 @@ export type {
   UnifiedButtonProps,
 } from './button';
 export type { CardProps, CardVariant } from './card';
-export type { InputProps } from './input';
+export type { CardLinkProps } from './card-link';
+export type { CheckboxGroupProps, CheckboxItem } from './checkbox-group';
+export type { ContainerPadding, ContainerProps, ContainerSize } from './container';
+export type { DividerOrientation, DividerProps, DividerVariant } from './divider';
+export type { AlignItems, FlexDirection, FlexProps, JustifyContent } from './flex';
 export type {
-  FormGroupProps,
-  FormGroupVariant,
   FormGroupLayout,
+  FormGroupProps,
   FormGroupSpacing,
+  FormGroupVariant,
 } from './form-group';
+export type { GridColumns, GridProps, ResponsiveGridColumns } from './grid';
+export type { HeroProps } from './hero';
+export type { InputProps } from './input';
+export type { LoginLayoutProps } from './login-layout';
 export type { MessageProps, MessageVariant } from './message';
-export type { ContainerProps, ContainerSize, ContainerPadding } from './container';
+export type { SpinnerProps, SpinnerSize } from './spinner';
 export type {
-  HeadingProps,
+  FontWeight,
   HeadingLevel,
-  TextProps,
-  TextSize,
+  HeadingProps,
+  LineHeight,
   TextAlignment,
   TextColor,
-  FontWeight,
-  LineHeight,
+  TextProps,
+  TextSize,
 } from './typography';
-export type { FlexProps, FlexDirection, JustifyContent, AlignItems } from './flex';
-export type { GridProps, GridColumns, ResponsiveGridColumns } from './grid';
-export type { HeroProps } from './hero';
-export type { SpinnerProps, SpinnerSize } from './spinner';
 export type { UserInfoBannerProps, UserInfoBannerVariant } from './user-info-banner';
-export type { DividerProps, DividerVariant, DividerOrientation } from './divider';
-export type { CheckboxGroupProps, CheckboxItem } from './checkbox-group';
-export type { LoginLayoutProps } from './login-layout';
-export type { CardLinkProps } from './card-link';
diff --git a/WeatherSpa/src/components/detail-card.css b/WeatherSpa/src/components/detail-card.css
index 6dc2313..35fe94c 100644
--- a/WeatherSpa/src/components/detail-card.css
+++ b/WeatherSpa/src/components/detail-card.css
@@ -1,14 +1,14 @@
-.detail-card {
+.ds-detail-card {
   border-top: 3px solid var(--primary);
-  background-color: var(--surface);
+  background-color: var(--color-surface);
   border-radius: 8px;
   padding: 1.5rem;
-  box-shadow: var(--shadow-sm);
+  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
   transition: box-shadow 0.2s;
   height: 100%;
 }
 
-.detail-card:hover {
+.ds-detail-card:hover {
   box-shadow: var(--shadow);
 }
 
@@ -22,4 +22,4 @@
 .detail-card-content {
   color: var(--text-secondary);
   line-height: 1.5;
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/hero.css b/WeatherSpa/src/components/hero.css
index 4a55818..33be03b 100644
--- a/WeatherSpa/src/components/hero.css
+++ b/WeatherSpa/src/components/hero.css
@@ -5,7 +5,7 @@
   position: relative;
   padding: 4rem 1.5rem 5rem;
   overflow: hidden;
-  background-color: var(--background);
+  background-color: var(--color-background);
   /* Better handling of full-width hero that works with scrollbars */
   box-sizing: border-box;
 }
@@ -13,7 +13,7 @@
 .ds-hero-title {
   font-size: 3.2rem;
   margin-bottom: 0.7rem;
-  color: var(--primary);
+  color: var(--color-primary);
   position: relative;
   display: inline-block;
 }
@@ -25,12 +25,12 @@
   left: 0;
   right: 0;
   height: 4px;
-  background: linear-gradient(90deg, transparent, var(--primary), transparent);
+  background: linear-gradient(90deg, transparent, var(--color-primary), transparent);
 }
 
 .ds-hero-subtitle {
   font-size: 1.4rem;
-  color: var(--text-secondary);
+  color: var(--color-text-secondary);
   margin-top: 1.8rem;
   margin-bottom: 3.5rem;
   max-width: 600px;
@@ -47,47 +47,39 @@
   left: 0;
   right: 0;
   bottom: 0;
-  background-image: 
+  background-image:
     /* Primary thin rain lines */
-    linear-gradient(
-      113deg,
+    linear-gradient(113deg,
       transparent 0%,
       transparent 49.5%,
       rgba(var(--primary-rgb), 0.2) 49.5%,
       rgba(var(--primary-rgb), 0.2) 50.5%,
       transparent 50.5%,
-      transparent 100%
-    ),
+      transparent 100%),
     /* Secondary thin lines at slightly different angle */
-      linear-gradient(
-        117deg,
-        transparent 0%,
-        transparent 49.7%,
-        rgba(var(--primary-rgb), 0.13) 49.7%,
-        rgba(var(--primary-rgb), 0.13) 50.3%,
-        transparent 50.3%,
-        transparent 100%
-      ),
+    linear-gradient(117deg,
+      transparent 0%,
+      transparent 49.7%,
+      rgba(var(--primary-rgb), 0.13) 49.7%,
+      rgba(var(--primary-rgb), 0.13) 50.3%,
+      transparent 50.3%,
+      transparent 100%),
     /* Thicker lines */
-      linear-gradient(
-        115deg,
-        transparent 0%,
-        transparent 49.6%,
-        rgba(var(--primary-rgb), 0.09) 49.6%,
-        rgba(var(--primary-rgb), 0.09) 50.4%,
-        transparent 50.4%,
-        transparent 100%
-      ),
+    linear-gradient(115deg,
+      transparent 0%,
+      transparent 49.6%,
+      rgba(var(--primary-rgb), 0.09) 49.6%,
+      rgba(var(--primary-rgb), 0.09) 50.4%,
+      transparent 50.4%,
+      transparent 100%),
     /* Extra thick occasional lines */
-      linear-gradient(
-        110deg,
-        transparent 0%,
-        transparent 49.8%,
-        rgba(var(--primary-rgb), 0.06) 49.8%,
-        rgba(var(--primary-rgb), 0.06) 50.2%,
-        transparent 50.2%,
-        transparent 100%
-      );
+    linear-gradient(110deg,
+      transparent 0%,
+      transparent 49.8%,
+      rgba(var(--primary-rgb), 0.06) 49.8%,
+      rgba(var(--primary-rgb), 0.06) 50.2%,
+      transparent 50.2%,
+      transparent 100%);
   background-size:
     28px 28px,
     33px 33px,
@@ -99,22 +91,18 @@
     fadeInGrid 1.2s ease-out forwards,
     rainAnimation 20s linear infinite;
   /* Make the grid fade out as we move down while keeping visibility on the left */
-  mask-image: linear-gradient(
-    to bottom,
-    rgba(0, 0, 0, 1) 0%,
-    rgba(0, 0, 0, 0.85) 40%,
-    rgba(0, 0, 0, 0.7) 60%,
-    rgba(0, 0, 0, 0.4) 80%,
-    rgba(0, 0, 0, 0) 100%
-  );
-  -webkit-mask-image: linear-gradient(
-    to bottom,
-    rgba(0, 0, 0, 1) 0%,
-    rgba(0, 0, 0, 0.85) 40%,
-    rgba(0, 0, 0, 0.7) 60%,
-    rgba(0, 0, 0, 0.4) 80%,
-    rgba(0, 0, 0, 0) 100%
-  );
+  mask-image: linear-gradient(to bottom,
+      rgba(0, 0, 0, 1) 0%,
+      rgba(0, 0, 0, 0.85) 40%,
+      rgba(0, 0, 0, 0.7) 60%,
+      rgba(0, 0, 0, 0.4) 80%,
+      rgba(0, 0, 0, 0) 100%);
+  -webkit-mask-image: linear-gradient(to bottom,
+      rgba(0, 0, 0, 1) 0%,
+      rgba(0, 0, 0, 0.85) 40%,
+      rgba(0, 0, 0, 0.7) 60%,
+      rgba(0, 0, 0, 0.4) 80%,
+      rgba(0, 0, 0, 0) 100%);
 }
 
 .ds-hero-content {
@@ -127,6 +115,7 @@
   0% {
     opacity: 0;
   }
+
   100% {
     opacity: 1;
   }
@@ -140,6 +129,7 @@
       0 0,
       0 0;
   }
+
   100% {
     background-position:
       -28px 28px,
@@ -168,4 +158,4 @@
     font-size: 1.25rem;
     margin-bottom: 2.5rem;
   }
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/input.css b/WeatherSpa/src/components/input.css
index 135f4dc..ae12b5c 100644
--- a/WeatherSpa/src/components/input.css
+++ b/WeatherSpa/src/components/input.css
@@ -1,15 +1,13 @@
 /* Input styles */
 .ds-input {
   width: 100%;
-  padding: 0.75rem 1rem;
-  border: 1px solid var(--border);
-  border-radius: 6px;
-  font-size: 0.95rem;
-  background-color: var(--surface);
-  color: var(--text-primary);
-  transition:
-    border-color 0.2s,
-    box-shadow 0.2s;
+  padding: 0.5rem 0.75rem;
+  border: 1px solid var(--color-border);
+  border-radius: 4px;
+  background-color: var(--color-surface);
+  color: var(--color-text);
+  font-size: 1rem;
+  transition: border-color 0.2s, box-shadow 0.2s;
   height: 42px;
 }
 
@@ -54,9 +52,13 @@
 
 /* Disabled state */
 .ds-input:disabled {
-  background-color: var(--surface-hover);
+  background-color: var(--color-surface-hover);
   color: var(--text-tertiary);
   cursor: not-allowed;
 }
 
 /* Dark mode adjustments are handled through CSS variables */
+
+.ds-input:hover {
+  background-color: rgba(var(--primary-rgb), 0.05);
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/layout.css b/WeatherSpa/src/components/layout.css
index 122925c..9920c2c 100644
--- a/WeatherSpa/src/components/layout.css
+++ b/WeatherSpa/src/components/layout.css
@@ -13,7 +13,7 @@
   justify-content: space-between;
   align-items: center;
   padding: 1rem;
-  background-color: var(--surface);
+  background-color: var(--color-surface);
   box-shadow: var(--shadow-sm);
   width: 100%;
   position: relative;
@@ -205,27 +205,33 @@
 }
 
 .ds-max-w-xs {
-  max-width: 20rem; /* 320px */
+  max-width: 20rem;
+  /* 320px */
 }
 
 .ds-max-w-sm {
-  max-width: 30rem; /* 480px */
+  max-width: 30rem;
+  /* 480px */
 }
 
 .ds-max-w-md {
-  max-width: 40rem; /* 640px */
+  max-width: 40rem;
+  /* 640px */
 }
 
 .ds-max-w-lg {
-  max-width: 50rem; /* 800px */
+  max-width: 50rem;
+  /* 800px */
 }
 
 .ds-max-w-xl {
-  max-width: 60rem; /* 960px */
+  max-width: 60rem;
+  /* 960px */
 }
 
 .ds-max-w-2xl {
-  max-width: 70rem; /* 1120px */
+  max-width: 70rem;
+  /* 1120px */
 }
 
 /* Height utilities */
@@ -321,4 +327,4 @@
 
 .ds-overflow-y-auto {
   overflow-y: auto;
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/layout.tsx b/WeatherSpa/src/components/layout.tsx
index 3bdda81..4135dfe 100644
--- a/WeatherSpa/src/components/layout.tsx
+++ b/WeatherSpa/src/components/layout.tsx
@@ -55,7 +55,7 @@ function Layout({ children }: LayoutProps) {
       {isAuthenticated && user && (
         <UserInfoBanner
           user={user}
-          displayedScopes={['read', 'write']}
+          displayedScopes={['weather.read', 'weather.write']}
           aria-label="User information and permissions"
         />
       )}
diff --git a/WeatherSpa/src/components/login-layout.css b/WeatherSpa/src/components/login-layout.css
index 30b6733..77e9748 100644
--- a/WeatherSpa/src/components/login-layout.css
+++ b/WeatherSpa/src/components/login-layout.css
@@ -1,3 +1,22 @@
+.ds-login-layout {
+  min-height: 100vh;
+  display: flex;
+  flex-direction: column;
+  align-items: center;
+  justify-content: center;
+  padding: 2rem;
+  background-color: var(--color-background);
+}
+
+.ds-login-card {
+  width: 100%;
+  max-width: 400px;
+  padding: 2rem;
+  background-color: var(--color-surface);
+  border-radius: 8px;
+  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
+}
+
 .login-layout {
   display: block;
   padding: 0 1rem 2rem;
@@ -42,7 +61,7 @@
 }
 
 .login-form-section {
-  background-color: var(--surface);
+  background-color: var(--color-surface);
   border-radius: 8px;
   padding: 1.5rem;
   box-shadow: var(--shadow-sm);
@@ -51,7 +70,7 @@
   flex-direction: column;
   gap: 1.2rem;
 
-  & > form {
+  &>form {
     display: flex;
     flex-direction: column;
     gap: 1.2rem;
@@ -62,4 +81,4 @@
   margin-bottom: 1.5rem;
   color: var(--text-secondary);
   line-height: 1.5;
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/components/user-info-banner.tsx b/WeatherSpa/src/components/user-info-banner.tsx
index dcad2a9..c626fb0 100644
--- a/WeatherSpa/src/components/user-info-banner.tsx
+++ b/WeatherSpa/src/components/user-info-banner.tsx
@@ -44,7 +44,7 @@ export const UserInfoBanner = forwardRef<HTMLDivElement, UserInfoBannerProps>(
       user,
       variant = 'default',
       compact = false,
-      displayedScopes = ['read', 'write'],
+      displayedScopes = ['weather.read', 'weather.write'],
       className = '',
       ...props
     },
@@ -83,7 +83,10 @@ export const UserInfoBanner = forwardRef<HTMLDivElement, UserInfoBannerProps>(
                 title={isActive ? `Has ${scope} permission` : `Does not have ${scope} permission`}
               >
                 <span className="ds-scope-badge-icon">{isActive ? '✓' : '✗'}</span>
-                {scope.charAt(0).toUpperCase() + scope.slice(1)}
+                {scope
+                  .split('.')
+                  .map(word => word.charAt(0).toUpperCase() + word.slice(1))
+                  .join(' ')}
               </div>
             );
           })}
diff --git a/WeatherSpa/src/components/weather-card.css b/WeatherSpa/src/components/weather-card.css
index 291a81f..4630dd3 100644
--- a/WeatherSpa/src/components/weather-card.css
+++ b/WeatherSpa/src/components/weather-card.css
@@ -1,9 +1,18 @@
+.ds-weather-card {
+  background-color: var(--color-surface);
+  border-radius: 8px;
+  padding: 1.5rem;
+  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
+  transition: transform 0.2s, box-shadow 0.2s;
+}
+
 .weather-card {
-  background-color: var(--surface);
+  background-color: var(--color-surface);
   border-radius: 8px;
   box-shadow: var(--shadow);
   padding: 1rem;
-  margin-bottom: 0; /* Remove margin since container has gap */
+  margin-bottom: 0;
+  /* Remove margin since container has gap */
   display: flex;
   align-items: center;
   transition: box-shadow 0.2s;
@@ -82,4 +91,4 @@
 
 .temp-f {
   color: var(--text-secondary);
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/contexts/auth-context.tsx b/WeatherSpa/src/contexts/auth-context.tsx
index 029cf17..d7e75d4 100644
--- a/WeatherSpa/src/contexts/auth-context.tsx
+++ b/WeatherSpa/src/contexts/auth-context.tsx
@@ -1,15 +1,18 @@
 import { jwtDecode } from 'jwt-decode';
 import { createContext, ReactNode, useContext, useEffect, useState } from 'react';
 import { useNavigate } from 'react-router-dom';
-import { AuthState, Claims, User } from '../types';
+import { refreshAccessToken } from '../services/auth-service';
+import { Claims, User } from '../types';
 
-interface AuthContextType extends AuthState {
-  login: (token: string, refreshToken: string) => void;
+interface AuthContextType {
+  isAuthenticated: boolean;
+  user: User | null;
+  login: (token: string, refreshToken?: string, rememberMe?: boolean) => void;
   logout: () => void;
   getToken: () => string | null;
 }
 
-const AuthContext = createContext<AuthContextType | undefined>(undefined);
+const AuthContext = createContext<AuthContextType | null>(null);
 
 interface AuthProviderProps {
   children: ReactNode;
@@ -17,85 +20,27 @@ interface AuthProviderProps {
 
 export function AuthProvider({ children }: AuthProviderProps) {
   const navigate = useNavigate();
-  const [authState, setAuthState] = useState<AuthState>({
-    isAuthenticated: false,
-    user: null,
-    token: null,
-    loading: true,
-    error: null,
-  });
+  const [isAuthenticated, setIsAuthenticated] = useState(false);
+  const [isInitialLogin, setIsInitialLogin] = useState(false);
+  const [user, setUser] = useState<User | null>(null);
 
   useEffect(() => {
-    // Check for token in sessionStorage on app load
-    const token = sessionStorage.getItem('auth_token');
-    const refreshToken = sessionStorage.getItem('refresh_token');
-
-    if (token && refreshToken) {
-      try {
-        // Decode user info from token
-        const decoded = jwtDecode<Claims>(token);
-
-        const expiryDate = new Date(decoded.exp * 1000);
-
-        // If token is expired, clear auth state
-        if (expiryDate < new Date()) {
-          console.log('Token expired, clearing auth state');
-          clearAuthData();
-          setAuthState({
-            isAuthenticated: false,
-            user: null,
-            token: null,
-            loading: false,
-            error: 'Token expired. Please login again.',
-          });
-          return;
-        }
-
-        const user: User = {
-          userId: decoded.sub,
-          username: decoded.name || decoded.sub,
-          tenant: decoded.tenant || '',
-          roles: decoded.roles || [],
-          scopes: decoded.scope || [],
-        };
-
-        setAuthState({
-          isAuthenticated: true,
-          user,
-          token,
-          loading: false,
-          error: null,
-        });
-      } catch (error) {
-        console.error('Error decoding token:', error);
-        clearAuthData();
-        setAuthState({
-          isAuthenticated: false,
-          user: null,
-          token: null,
-          loading: false,
-          error: 'Invalid authentication token',
+    // Only check for refresh token if we haven't just logged in
+    if (!isInitialLogin) {
+      // Check both storage locations for refresh token
+      const refreshToken = localStorage.getItem('refresh_token') || sessionStorage.getItem('refresh_token');
+      if (refreshToken) {
+        refreshAccessToken().then(authData => {
+          if (authData) {
+            login(authData.access_token, authData.refresh_token);
+          }
         });
       }
-    } else {
-      setAuthState(prev => ({ ...prev, loading: false }));
     }
-  }, []);
-
-  function clearAuthData() {
-    console.log('Clearing auth data');
-    sessionStorage.removeItem('auth_token');
-    sessionStorage.removeItem('refresh_token');
-    sessionStorage.removeItem('auth_state');
-  }
+  }, [isInitialLogin]);
 
-  function login(token: string, refreshToken: string) {
-    console.log('Auth context login called with token and refresh token');
+  const login = (token: string, refreshToken?: string, rememberMe: boolean = false) => {
     try {
-      // Store tokens in sessionStorage
-      sessionStorage.setItem('auth_token', token);
-      sessionStorage.setItem('refresh_token', refreshToken);
-
       // Decode user info from token
       const decoded = jwtDecode<Claims>(token);
       const user: User = {
@@ -103,55 +48,43 @@ export function AuthProvider({ children }: AuthProviderProps) {
         username: decoded.name || decoded.sub,
         tenant: decoded.tenant || '',
         roles: decoded.roles || [],
-        scopes: decoded.scope || [],
+        scopes: (decoded.scope || []) as string[],
       };
 
-      setAuthState({
-        isAuthenticated: true,
-        user,
-        token,
-        loading: false,
-        error: null,
-      });
-
+      sessionStorage.setItem('access_token', token);
+      if (refreshToken) {
+        if (rememberMe) {
+          localStorage.setItem('refresh_token', refreshToken);
+        } else {
+          sessionStorage.setItem('refresh_token', refreshToken);
+        }
+      }
+      setIsAuthenticated(true);
+      setIsInitialLogin(true);
+      setUser(user);
       navigate('/forecasts');
     } catch (error) {
-      console.error('Login error:', error);
-      setAuthState({
-        isAuthenticated: false,
-        user: null,
-        token: null,
-        loading: false,
-        error: 'Failed to authenticate',
-      });
+      console.error('Error decoding token:', error);
+      logout();
     }
-  }
+  };
 
-  function logout() {
-    clearAuthData();
-    setAuthState({
-      isAuthenticated: false,
-      user: null,
-      token: null,
-      loading: false,
-      error: null,
-    });
+  const logout = () => {
+    sessionStorage.removeItem('access_token');
+    localStorage.removeItem('refresh_token');
+    sessionStorage.removeItem('refresh_token');
+    setIsAuthenticated(false);
+    setIsInitialLogin(false);
+    setUser(null);
     navigate('/');
-  }
+  };
 
-  function getToken() {
-    return authState.token;
-  }
+  const getToken = () => {
+    return sessionStorage.getItem('access_token');
+  };
 
   return (
-    <AuthContext.Provider
-      value={{
-        ...authState,
-        login,
-        logout,
-        getToken,
-      }}
-    >
+    <AuthContext.Provider value={{ isAuthenticated, user, login, logout, getToken }}>
       {children}
     </AuthContext.Provider>
   );
@@ -160,7 +93,7 @@ export function AuthProvider({ children }: AuthProviderProps) {
 // eslint-disable-next-line react-refresh/only-export-components
 export function useAuth() {
   const context = useContext(AuthContext);
-  if (context === undefined) {
+  if (!context) {
     throw new Error('useAuth must be used within an AuthProvider');
   }
   return context;
diff --git a/WeatherSpa/src/index.css b/WeatherSpa/src/index.css
index ee3e60b..7e1672f 100644
--- a/WeatherSpa/src/index.css
+++ b/WeatherSpa/src/index.css
@@ -4,8 +4,18 @@
   font-weight: 400;
 
   color-scheme: light dark;
-  color: #213547;
-  background-color: #f8fafc;
+
+  /* Light mode colors */
+  --color-text: #213547;
+  --color-text-secondary: #64748b;
+  --color-background: #f8fafc;
+  --color-surface: #ffffff;
+  --color-surface-hover: #f1f5f9;
+  --color-border: #e2e8f0;
+  --color-primary: #3b82f6;
+  --color-error: #ef4444;
+  --color-success: #22c55e;
+  --color-warning: #f59e0b;
 
   font-synthesis: none;
   text-rendering: optimizeLegibility;
@@ -13,14 +23,31 @@
   -moz-osx-font-smoothing: grayscale;
 }
 
+@media (prefers-color-scheme: dark) {
+  :root {
+    --color-text: #f8fafc;
+    --color-text-secondary: #94a3b8;
+    --color-background: #0f172a;
+    --color-surface: #1e293b;
+    --color-surface-hover: #334155;
+    --color-border: #334155;
+    --color-primary: #60a5fa;
+    --color-error: #f87171;
+    --color-success: #4ade80;
+    --color-warning: #fbbf24;
+  }
+}
+
 body {
   margin: 0;
   min-width: 320px;
   min-height: 100vh;
+  color: var(--color-text);
+  background-color: var(--color-background);
 }
 
 #root {
   display: flex;
   flex-direction: column;
   min-height: 100vh;
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/pages/auth-callback-page.tsx b/WeatherSpa/src/pages/auth-callback-page.tsx
index 03d0ae3..3350f79 100644
--- a/WeatherSpa/src/pages/auth-callback-page.tsx
+++ b/WeatherSpa/src/pages/auth-callback-page.tsx
@@ -1,55 +1,81 @@
 import { useEffect, useState } from 'react';
-import { Navigate, useLocation } from 'react-router-dom';
-import { Button, Card, Spinner, Container, Heading, Text, Flex } from '../components/design-system';
+import { useLocation, useNavigate } from 'react-router-dom';
+import { Button, Card, Container, Flex, Heading, Spinner, Text } from '../components/design-system';
 import { useAuth } from '../contexts/auth-context';
 import { processAuthCallback } from '../services/auth-service';
 import './auth-callback-page.css';
 
 export default function AuthCallbackPage() {
   const location = useLocation();
+  const navigate = useNavigate();
   const { login } = useAuth();
   const [error, setError] = useState<string | null>(null);
   const [processing, setProcessing] = useState(true);
 
   useEffect(() => {
-    try {
-      const queryParams = new URLSearchParams(location.search);
-      const authData = processAuthCallback(queryParams);
+    const handleCallback = async () => {
+      try {
+        const queryParams = new URLSearchParams(location.search);
 
-      if (!authData) {
-        setError('Authentication failed. Invalid or missing parameters.');
-        setProcessing(false);
-        return;
-      }
+        // Check for error parameters first
+        const error = queryParams.get('error');
+        const errorDescription = queryParams.get('error_description');
 
-      // Process successful authentication
-      login(authData.token, authData.refreshToken);
+        if (error) {
+          setError(errorDescription || error);
+          setProcessing(false);
+          return;
+        }
 
-      setProcessing(false);
-    } catch (error) {
-      console.error('Error processing authentication callback:', error);
-      setError('An error occurred while processing the authentication.');
-      setProcessing(false);
-    }
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, []);
+        // Get remember me preference from session storage
+        const rememberMe = sessionStorage.getItem('remember_me') === 'true';
 
-  if (!processing && !error) {
-    return <Navigate to="/forecasts" replace />;
-  }
+        const authData = await processAuthCallback(queryParams, rememberMe);
+
+        if (!authData) {
+          setError('Authentication failed');
+          setProcessing(false);
+          return;
+        }
+
+        // Login with the new tokens
+        login(authData.access_token, authData.refresh_token, rememberMe);
+
+        // Clear remember me preference
+        sessionStorage.removeItem('remember_me');
+
+        // Redirect to home page after successful authentication
+        navigate('/');
+
+        setProcessing(false);
+      } catch (err) {
+        console.error('Error processing auth callback:', err);
+        setError(err instanceof Error ? err.message : 'Authentication failed');
+        setProcessing(false);
+      }
+    };
+
+    handleCallback();
+  }, [location, login, navigate]);
 
-  return (
-    <Container className="auth-callback-page">
-      {processing ? (
+  if (processing) {
+    return (
+      <Container className="auth-callback-page">
         <Card className="callback-container">
-          <Flex direction="column" align="center">
+          <Flex direction="col" align="center">
             <Spinner size="lg" text="Processing authentication..." />
             <Text color="secondary" className="callback-message">
               Please wait while we complete your login.
             </Text>
           </Flex>
         </Card>
-      ) : (
+      </Container>
+    );
+  }
+
+  if (error) {
+    return (
+      <Container className="auth-callback-page">
         <Card className="callback-container error">
           <Heading level={2} color="error">
             Authentication Error
@@ -59,7 +85,9 @@ export default function AuthCallbackPage() {
             Back to Login
           </Button>
         </Card>
-      )}
-    </Container>
-  );
+      </Container>
+    );
+  }
+
+  return null;
 }
diff --git a/WeatherSpa/src/pages/forecasts-page.css b/WeatherSpa/src/pages/forecasts-page.css
index 54d7df8..d2b9500 100644
--- a/WeatherSpa/src/pages/forecasts-page.css
+++ b/WeatherSpa/src/pages/forecasts-page.css
@@ -38,7 +38,7 @@
 }
 
 .forecast-row:hover {
-  background-color: var(--surface-hover);
+  background-color: rgba(var(--primary-rgb), 0.05);
 }
 
 .date-cell {
@@ -150,4 +150,4 @@
   .temp-divider {
     display: none;
   }
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/pages/forecasts-page.tsx b/WeatherSpa/src/pages/forecasts-page.tsx
index 67bf05a..a79f656 100644
--- a/WeatherSpa/src/pages/forecasts-page.tsx
+++ b/WeatherSpa/src/pages/forecasts-page.tsx
@@ -20,8 +20,8 @@ export default function ForecastsPage() {
   const [error, setError] = useState<string | null>(null);
 
   // Check scopes
-  const hasReadScope = user?.scopes.includes('read');
-  const hasWriteScope = user?.scopes.includes('write');
+  const hasReadScope = user?.scopes.includes('weather.read');
+  const hasWriteScope = user?.scopes.includes('weather.write');
 
   useEffect(() => {
     async function fetchForecasts() {
diff --git a/WeatherSpa/src/pages/redirect-login-page.tsx b/WeatherSpa/src/pages/redirect-login-page.tsx
index 84e4a27..54a07e8 100644
--- a/WeatherSpa/src/pages/redirect-login-page.tsx
+++ b/WeatherSpa/src/pages/redirect-login-page.tsx
@@ -1,23 +1,32 @@
 import { useState } from 'react';
-import { Button, Input, LoginLayout, CheckboxGroup, Spinner } from '../components/design-system';
+import {
+  Button,
+  Checkbox,
+  CheckboxGroup,
+  Input,
+  LoginLayout,
+  Spinner,
+} from '../components/design-system';
 import { initiateAuthRedirect } from '../services/auth-service';
 import './login-page.css';
 
 // Available scopes for selection
 const availableScopes = [
-  { id: 'user_info', label: 'User Info', description: 'Access to basic user information' },
+  { id: 'openid', label: 'OpenID Connect', description: 'Access to OpenID Connect functionality' },
   { id: 'profile', label: 'Profile', description: 'Access to detailed profile information' },
   { id: 'email', label: 'Email', description: 'Access to email address' },
-  { id: 'read', label: 'Read Data', description: 'Read-only access to data' },
-  { id: 'write', label: 'Write Data', description: 'Write access to data' },
+  { id: 'weather.read', label: 'Weather Data', description: 'Read access to weather data' },
 ];
 
 export default function RedirectLoginPage() {
   const [tenant, setTenant] = useState('tenant1');
   const [loading, setLoading] = useState(false);
+  const [rememberMe, setRememberMe] = useState(false);
   const [selectedScopes, setSelectedScopes] = useState<{ [key: string]: boolean }>({
-    user_info: true,
-    read: true,
+    openid: true,
+    profile: true,
+    email: true,
+    'weather.read': true,
   });
 
   function handleScopeChange(scopeId: string, checked: boolean) {
@@ -27,20 +36,23 @@ export default function RedirectLoginPage() {
     }));
   }
 
-  function handleRedirectLogin() {
+  async function handleRedirectLogin() {
     const scopes = Object.entries(selectedScopes)
       // eslint-disable-next-line @typescript-eslint/no-unused-vars
       .filter(([_, selected]) => selected)
       .map(([scope]) => scope);
 
+    // Store remember me preference in session storage
+    sessionStorage.setItem('remember_me', rememberMe.toString());
+
     setLoading(true);
-    initiateAuthRedirect(tenant, scopes);
+    await initiateAuthRedirect(tenant, scopes);
   }
 
   return (
     <LoginLayout
       title="Redirect Login"
-      description="Login using the redirect flow. You'll be redirected to the Auth Server for authentication."
+      description="Login using the OAuth 2.0 Authorization Code flow with PKCE. You'll be redirected to the Auth Server for authentication."
       showBackButton
     >
       <Input
@@ -67,13 +79,21 @@ export default function RedirectLoginPage() {
         idPrefix="scope-redirect"
       />
 
+      <Checkbox
+        id="remember-me"
+        label="Remember me"
+        checked={rememberMe}
+        onChange={checked => setRememberMe(checked)}
+        helper="Stay logged in across browser sessions"
+      />
+
       <Button variant="primary" onClick={handleRedirectLogin} disabled={loading} fullWidth>
         {loading ? (
           <>
             <Spinner size="sm" /> Redirecting...
           </>
         ) : (
-          'Login with Redirect'
+          'Login with OAuth'
         )}
       </Button>
     </LoginLayout>
diff --git a/WeatherSpa/src/pages/unauthorized-page.css b/WeatherSpa/src/pages/unauthorized-page.css
index 05f97c2..cdbe369 100644
--- a/WeatherSpa/src/pages/unauthorized-page.css
+++ b/WeatherSpa/src/pages/unauthorized-page.css
@@ -1,18 +1,20 @@
 .unauthorized-page {
   display: flex;
+  flex-direction: column;
+  align-items: center;
   justify-content: center;
-  align-items: flex-start;
-  padding: 2rem 1rem;
+  min-height: 100vh;
+  padding: 2rem;
+  background-color: var(--color-background);
 }
 
-.unauthorized-container {
-  background-color: var(--surface);
+.unauthorized-card {
+  background-color: var(--color-surface);
   border-radius: 8px;
-  box-shadow: var(--shadow);
   padding: 2rem;
-  width: 100%;
-  max-width: 600px;
   text-align: center;
+  max-width: 400px;
+  width: 100%;
 }
 
 .icon {
@@ -73,4 +75,4 @@
 .unauthorized-message {
   margin-bottom: 2rem;
   font-size: 1.1rem;
-}
+}
\ No newline at end of file
diff --git a/WeatherSpa/src/services/auth-service.ts b/WeatherSpa/src/services/auth-service.ts
index f3d0099..b1984e6 100644
--- a/WeatherSpa/src/services/auth-service.ts
+++ b/WeatherSpa/src/services/auth-service.ts
@@ -2,6 +2,17 @@
 import { AuthToken } from '../types';
 import { authApi } from './api';
 
+// Constants
+const AUTH_SERVER_URL = import.meta.env.VITE_AUTH_SERVER_URL || 'http://localhost:5143';
+
+// Types
+interface AuthData {
+  access_token: string;
+  refresh_token: string;
+  expires_in: number;
+  token_type: string;
+}
+
 // Generate a cryptographically strong random string for state
 export const generateRandomState = (): string => {
   return (([1e7] as any) + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c: any) =>
@@ -9,15 +20,42 @@ export const generateRandomState = (): string => {
   );
 };
 
+// Generate PKCE code verifier and challenge
+export const generatePkcePair = async (): Promise<{
+  codeVerifier: string;
+  codeChallenge: string;
+}> => {
+  // Generate a random code verifier
+  const codeVerifier = generateRandomState();
+
+  // Generate the code challenge using SHA-256
+  const encoder = new TextEncoder();
+  const data = encoder.encode(codeVerifier);
+  const hash = await crypto.subtle.digest('SHA-256', data);
+  const codeChallenge = btoa(String.fromCharCode(...new Uint8Array(hash)))
+    .replace(/\+/g, '-')
+    .replace(/\//g, '_')
+    .replace(/=+$/, '');
+
+  return { codeVerifier, codeChallenge };
+};
+
 // Initiate the redirect-based authentication flow
-export const initiateAuthRedirect = (tenant: string = '', scopes: string[] = ['user_info']) => {
+export const initiateAuthRedirect = async (
+  tenant: string = '',
+  scopes: string[] = ['openid', 'profile', 'email']
+) => {
   const state = generateRandomState();
   const redirectUri = `${window.location.origin}/callback`;
+  const { codeVerifier, codeChallenge } = await generatePkcePair();
+  const clientId = 'weather-spa'; // Our client ID
 
-  sessionStorage.setItem('auth_state', state);
+  // Store state and code verifier in session storage
+  sessionStorage.setItem('oauth_state', state);
+  sessionStorage.setItem('code_verifier', codeVerifier);
 
   // Build the redirect URL
-  let authUrl = `${authApi.defaults.baseURL}/api/authorize?redirectUri=${encodeURIComponent(redirectUri)}&state=${state}`;
+  let authUrl = `${authApi.defaults.baseURL}/oauth/authorize?client_id=${encodeURIComponent(clientId)}&redirect_uri=${encodeURIComponent(redirectUri)}&state=${state}&response_type=code&code_challenge=${codeChallenge}&code_challenge_method=S256`;
 
   // Add tenant if provided
   if (tenant) {
@@ -26,7 +64,7 @@ export const initiateAuthRedirect = (tenant: string = '', scopes: string[] = ['u
 
   // Add scopes if provided (space-separated as per OAuth2 standard)
   if (scopes && scopes.length > 0) {
-    authUrl += `&scopes=${encodeURIComponent(scopes.join(' '))}`;
+    authUrl += `&scope=${encodeURIComponent(scopes.join(' '))}`;
   }
 
   // Redirect to the authorization URL
@@ -34,51 +72,144 @@ export const initiateAuthRedirect = (tenant: string = '', scopes: string[] = ['u
 };
 
 // Process the callback after authentication redirect
-export const processAuthCallback = (
-  queryParams: URLSearchParams
-): {
-  token: string;
-  refreshToken: string;
-  state: string;
-} | null => {
-  const token = queryParams.get('token');
-  const refreshToken = queryParams.get('refreshToken');
+export async function processAuthCallback(
+  queryParams: URLSearchParams,
+  rememberMe: boolean = false
+): Promise<AuthData | null> {
+  const code = queryParams.get('code');
   const state = queryParams.get('state');
-  const storedState = sessionStorage.getItem('auth_state');
+  const error = queryParams.get('error');
+  const errorDescription = queryParams.get('error_description');
+
+  if (error) {
+    console.error('OAuth error:', error, errorDescription);
+    throw new Error(errorDescription || error);
+  }
 
-  if (!token) {
-    console.error('Missing token parameter in callback');
+  if (!code) {
+    console.error('No authorization code received');
     return null;
   }
 
-  if (!refreshToken) {
-    console.error('Missing refreshToken parameter in callback');
+  // Verify state if it was sent
+  const storedState = sessionStorage.getItem('oauth_state');
+  if (state && storedState !== state) {
+    console.error('State mismatch', { state, storedState });
     return null;
   }
 
-  if (!state) {
-    console.error('Missing state parameter in callback');
+  const tokenEndpoint = `${AUTH_SERVER_URL}/oauth/token`;
+  const redirectUri = window.location.origin + '/callback';
+  const codeVerifier = sessionStorage.getItem('code_verifier');
+
+  if (!codeVerifier) {
+    console.error('No code verifier found');
     return null;
   }
 
-  if (state !== storedState) {
-    console.error('State parameter mismatch in callback');
+  const formData = new URLSearchParams();
+  formData.append('grant_type', 'authorization_code');
+  formData.append('code', code);
+  formData.append('redirect_uri', redirectUri);
+  formData.append('code_verifier', codeVerifier);
+  formData.append('client_id', 'weather-spa');
+  formData.append('remember_me', rememberMe.toString());
+
+  try {
+    const response = await fetch(tokenEndpoint, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/x-www-form-urlencoded',
+      },
+      body: formData,
+    });
+
+    if (!response.ok) {
+      const errorData = await response.json();
+      console.error('Token request failed:', errorData);
+      throw new Error(errorData.error_description || 'Failed to exchange code for token');
+    }
+
+    const data = await response.json();
+
+    // Store refresh token based on remember me preference
+    if (data.refresh_token) {
+      if (rememberMe) {
+        localStorage.setItem('refresh_token', data.refresh_token);
+      } else {
+        sessionStorage.setItem('refresh_token', data.refresh_token);
+      }
+    }
+
+    // Clear the code verifier and state from session storage
+    sessionStorage.removeItem('code_verifier');
+    sessionStorage.removeItem('oauth_state');
+
+    return {
+      access_token: data.access_token,
+      refresh_token: data.refresh_token,
+      expires_in: data.expires_in,
+      token_type: data.token_type,
+    };
+  } catch (error) {
+    console.error('Error exchanging code for token:', error);
+    throw error;
+  }
+}
+
+// Add a function to handle token refresh
+export async function refreshAccessToken(): Promise<AuthData | null> {
+  const refreshToken = localStorage.getItem('refresh_token');
+  if (!refreshToken) {
     return null;
   }
 
-  return {
-    token,
-    refreshToken,
-    state,
-  };
-};
+  const tokenEndpoint = `${AUTH_SERVER_URL}/oauth/token`;
+  const formData = new URLSearchParams();
+  formData.append('grant_type', 'refresh_token');
+  formData.append('refresh_token', refreshToken);
+  formData.append('client_id', 'weather-spa');
+
+  try {
+    const response = await fetch(tokenEndpoint, {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/x-www-form-urlencoded',
+      },
+      body: formData,
+    });
+
+    if (!response.ok) {
+      // If refresh fails, clear the stored refresh token
+      localStorage.removeItem('refresh_token');
+      return null;
+    }
+
+    const data = await response.json();
+
+    // Store the new refresh token
+    if (data.refresh_token) {
+      localStorage.setItem('refresh_token', data.refresh_token);
+    }
+
+    return {
+      access_token: data.access_token,
+      refresh_token: data.refresh_token,
+      expires_in: data.expires_in,
+      token_type: data.token_type,
+    };
+  } catch (error) {
+    console.error('Error refreshing token:', error);
+    return null;
+  }
+}
 
 // Direct login via API
 export const loginWithCredentials = async (
   username: string,
   password: string,
   tenant: string,
-  scopes: string[] = ['user_info', 'read', 'write']
+  scopes: string[] = ['openid', 'profile', 'email']
 ): Promise<AuthToken> => {
   const response = await authApi.post<AuthToken>('/api/login', {
     username,
@@ -89,3 +220,25 @@ export const loginWithCredentials = async (
 
   return response.data;
 };
+
+// Refresh the access token
+export const refreshToken = async (refreshToken: string): Promise<AuthToken> => {
+  // Create form data for the token request
+  const formData = new URLSearchParams();
+  formData.append('grant_type', 'refresh_token');
+  formData.append('refresh_token', refreshToken);
+
+  const response = await authApi.post<AuthToken>('/oauth/token', formData, {
+    headers: {
+      'Content-Type': 'application/x-www-form-urlencoded',
+    },
+  });
+
+  return response.data;
+};
+
+// Get user info
+export const getUserInfo = async (): Promise<any> => {
+  const response = await authApi.get('/oauth/userinfo');
+  return response.data;
+};
diff --git a/WeatherSpa/src/types/index.ts b/WeatherSpa/src/types/index.ts
index 0cacfed..7582b1f 100644
--- a/WeatherSpa/src/types/index.ts
+++ b/WeatherSpa/src/types/index.ts
@@ -6,22 +6,23 @@ export interface WeatherForecast {
 }
 
 export interface AuthToken {
-  token: string;
-  expiration: string;
-  refreshToken: string;
-  refreshTokenExpiration: string;
+  access_token: string;
+  expires_in: string;
+  refresh_token: string;
+  refresh_token_expires_in: string;
+  scope?: string;
 }
 
 export interface Claims {
-  aud: string;
+  sub: string;
+  name?: string;
+  tenant?: string;
+  roles?: string[];
+  scope?: string[];
   exp: number;
+  iat: number;
   iss: string;
-  jti: string;
-  sub: string;
-  name: string;
-  tenant: string;
-  roles: string[];
-  scope: string[];
+  aud: string;
 }
 
 export interface User {
-- 
2.43.0

